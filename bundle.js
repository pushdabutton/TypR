/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./scripts/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/GLTFLoader.js":
/*!**************************!*\
  !*** ./js/GLTFLoader.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// /**\n//  * @author Rich Tibbett / https://github.com/richtr\n//  * @author mrdoob / http://mrdoob.com/\n//  * @author Tony Parisi / http://www.tonyparisi.com/\n//  * @author Takahiro / https://github.com/takahirox\n//  * @author Don McCurdy / https://www.donmccurdy.com\n//  */\n/* harmony default export */ __webpack_exports__[\"default\"] = (THREE.GLTFLoader = function () {\n  function GLTFLoader(manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n    this.dracoLoader = null;\n  }\n\n  GLTFLoader.prototype = {\n    constructor: GLTFLoader,\n    crossOrigin: 'anonymous',\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== undefined) {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== undefined) {\n        resourcePath = this.path;\n      } else {\n        resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n      scope.manager.itemStart(url);\n\n      var _onError = function _onError(e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    },\n    setCrossOrigin: function setCrossOrigin(value) {\n      this.crossOrigin = value;\n      return this;\n    },\n    setPath: function setPath(value) {\n      this.path = value;\n      return this;\n    },\n    setResourcePath: function setResourcePath(value) {\n      this.resourcePath = value;\n      return this;\n    },\n    setDRACOLoader: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    },\n    parse: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n        return;\n      }\n\n      if (json.extensionsUsed) {\n        for (var i = 0; i < json.extensionsUsed.length; ++i) {\n          var extensionName = json.extensionsUsed[i];\n          var extensionsRequired = json.extensionsRequired || [];\n\n          switch (extensionName) {\n            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n              extensions[extensionName] = new GLTFLightsExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n\n            case EXTENSIONS.MSFT_TEXTURE_DDS:\n              extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension();\n              break;\n\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] = new GLTFTextureTransformExtension(json);\n              break;\n\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0) {\n                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n\n          }\n        }\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager\n      });\n      parser.parse(onLoad, onError);\n    }\n  };\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n  };\n  /**\n   * DDS Texture Extension\n   *\n   * Specification:\n   * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n   *\n   */\n\n  function GLTFTextureDDSExtension() {\n    if (!THREE.DDSLoader) {\n      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');\n    }\n\n    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n    this.ddsLoader = new THREE.DDSLoader();\n  }\n  /**\n   * Lights Extension\n   *\n   * Specification: PENDING\n   */\n\n\n  function GLTFLightsExtension(json) {\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};\n    this.lightDefs = extension.lights || [];\n  }\n\n  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n    var lightDef = this.lightDefs[lightIndex];\n    var lightNode;\n    var color = new THREE.Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new THREE.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new THREE.PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new THREE.SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = lightDef.name || 'light_' + lightIndex;\n    return Promise.resolve(lightNode);\n  };\n  /**\n   * Unlit Materials Extension (pending)\n   *\n   * PR: https://github.com/KhronosGroup/glTF/pull/1163\n   */\n\n\n  function GLTFMaterialsUnlitExtension(json) {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function (material) {\n    return THREE.MeshBasicMaterial;\n  };\n\n  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, material, parser) {\n    var pending = [];\n    materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    var metallicRoughness = material.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\n  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  var BINARY_EXTENSION_HEADER_LENGTH = 12;\n  var BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n  };\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n    }\n\n    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    var chunkIndex = 0;\n\n    while (chunkIndex < chunkView.byteLength) {\n      var chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      var chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = THREE.LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n  /**\n   * DRACO Mesh Compression Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/pull/874\n   */\n\n\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n  }\n\n  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n    var json = this.json;\n    var dracoLoader = this.dracoLoader;\n    var bufferViewIndex = primitive.extensions[this.name].bufferView;\n    var gltfAttributeMap = primitive.extensions[this.name].attributes;\n    var threeAttributeMap = {};\n    var attributeNormalizedMap = {};\n    var attributeTypeMap = {};\n\n    for (var attributeName in gltfAttributeMap) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (attributeName in primitive.attributes) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        var accessorDef = json.accessors[primitive.attributes[attributeName]];\n        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (var attributeName in geometry.attributes) {\n            var attribute = geometry.attributes[attributeName];\n            var normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  };\n  /**\n   * Texture Transform Extension\n   *\n   * Specification:\n   */\n\n\n  function GLTFTextureTransformExtension(json) {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    return {\n      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n      getMaterialType: function getMaterialType() {\n        return THREE.ShaderMaterial;\n      },\n      extendParams: function extendParams(params, material, parser) {\n        var pbrSpecularGlossiness = material.extensions[this.name];\n        var shader = THREE.ShaderLib['standard'];\n        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n        var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n        delete uniforms.roughness;\n        delete uniforms.metalness;\n        delete uniforms.roughnessMap;\n        delete uniforms.metalnessMap;\n        uniforms.specular = {\n          value: new THREE.Color().setHex(0x111111)\n        };\n        uniforms.glossiness = {\n          value: 0.5\n        };\n        uniforms.specularMap = {\n          value: null\n        };\n        uniforms.glossinessMap = {\n          value: null\n        };\n        params.vertexShader = shader.vertexShader;\n        params.fragmentShader = fragmentShader;\n        params.uniforms = uniforms;\n        params.defines = {\n          'STANDARD': ''\n        };\n        params.color = new THREE.Color(1.0, 1.0, 1.0);\n        params.opacity = 1.0;\n        var pending = [];\n\n        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n          var array = pbrSpecularGlossiness.diffuseFactor;\n          params.color.fromArray(array);\n          params.opacity = array[3];\n        }\n\n        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n          pending.push(parser.assignTexture(params, 'map', pbrSpecularGlossiness.diffuseTexture));\n        }\n\n        params.emissive = new THREE.Color(0.0, 0.0, 0.0);\n        params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n        params.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n          params.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n        }\n\n        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n          pending.push(parser.assignTexture(params, 'glossinessMap', specGlossMapDef));\n          pending.push(parser.assignTexture(params, 'specularMap', specGlossMapDef));\n        }\n\n        return Promise.all(pending);\n      },\n      createMaterial: function createMaterial(params) {\n        // setup material properties based on MeshStandardMaterial for Specular-Glossiness\n        var material = new THREE.ShaderMaterial({\n          defines: params.defines,\n          vertexShader: params.vertexShader,\n          fragmentShader: params.fragmentShader,\n          uniforms: params.uniforms,\n          fog: true,\n          lights: true,\n          opacity: params.opacity,\n          transparent: params.transparent\n        });\n        material.isGLTFSpecularGlossinessMaterial = true;\n        material.color = params.color;\n        material.map = params.map === undefined ? null : params.map;\n        material.lightMap = null;\n        material.lightMapIntensity = 1.0;\n        material.aoMap = params.aoMap === undefined ? null : params.aoMap;\n        material.aoMapIntensity = 1.0;\n        material.emissive = params.emissive;\n        material.emissiveIntensity = 1.0;\n        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n        material.bumpScale = 1;\n        material.normalMap = params.normalMap === undefined ? null : params.normalMap;\n        if (params.normalScale) material.normalScale = params.normalScale;\n        material.displacementMap = null;\n        material.displacementScale = 1;\n        material.displacementBias = 0;\n        material.specularMap = params.specularMap === undefined ? null : params.specularMap;\n        material.specular = params.specular;\n        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n        material.glossiness = params.glossiness;\n        material.alphaMap = null;\n        material.envMap = params.envMap === undefined ? null : params.envMap;\n        material.envMapIntensity = 1.0;\n        material.refractionRatio = 0.98;\n        material.extensions.derivatives = true;\n        return material;\n      },\n\n      /**\n       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n       * copy only properties it knows about or inherits, and misses many properties that would\n       * normally be defined by MeshStandardMaterial.\n       *\n       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n       * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n       * AND also updating `.onBeforeRender` on the parent mesh.\n       *\n       * @param  {THREE.ShaderMaterial} source\n       * @return {THREE.ShaderMaterial}\n       */\n      cloneMaterial: function cloneMaterial(source) {\n        var target = source.clone();\n        target.isGLTFSpecularGlossinessMaterial = true;\n        var params = this.specularGlossinessParams;\n\n        for (var i = 0, il = params.length; i < il; i++) {\n          target[params[i]] = source[params[i]];\n        }\n\n        return target;\n      },\n      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material, group) {\n        if (material.isGLTFSpecularGlossinessMaterial !== true) {\n          return;\n        }\n\n        var uniforms = material.uniforms;\n        var defines = material.defines;\n        uniforms.opacity.value = material.opacity;\n        uniforms.diffuse.value.copy(material.color);\n        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n        uniforms.map.value = material.map;\n        uniforms.specularMap.value = material.specularMap;\n        uniforms.alphaMap.value = material.alphaMap;\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.lightMapIntensity.value = material.lightMapIntensity;\n        uniforms.aoMap.value = material.aoMap;\n        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities\n        // 1. color map\n        // 2. specular map\n        // 3. normal map\n        // 4. bump map\n        // 5. alpha map\n        // 6. emissive map\n\n        var uvScaleMap;\n\n        if (material.map) {\n          uvScaleMap = material.map;\n        } else if (material.specularMap) {\n          uvScaleMap = material.specularMap;\n        } else if (material.displacementMap) {\n          uvScaleMap = material.displacementMap;\n        } else if (material.normalMap) {\n          uvScaleMap = material.normalMap;\n        } else if (material.bumpMap) {\n          uvScaleMap = material.bumpMap;\n        } else if (material.glossinessMap) {\n          uvScaleMap = material.glossinessMap;\n        } else if (material.alphaMap) {\n          uvScaleMap = material.alphaMap;\n        } else if (material.emissiveMap) {\n          uvScaleMap = material.emissiveMap;\n        }\n\n        if (uvScaleMap !== undefined) {\n          // backwards compatibility\n          if (uvScaleMap.isWebGLRenderTarget) {\n            uvScaleMap = uvScaleMap.texture;\n          }\n\n          if (uvScaleMap.matrixAutoUpdate === true) {\n            uvScaleMap.updateMatrix();\n          }\n\n          uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n        }\n\n        if (material.envMap) {\n          uniforms.envMap.value = material.envMap;\n          uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else:\n          //  WebGLRenderTargetCube will be flipped for backwards compatibility\n          //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n          // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\n          uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;\n          uniforms.reflectivity.value = material.reflectivity;\n          uniforms.refractionRatio.value = material.refractionRatio;\n          uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;\n        }\n\n        uniforms.specular.value.copy(material.specular);\n        uniforms.glossiness.value = material.glossiness;\n        uniforms.glossinessMap.value = material.glossinessMap;\n        uniforms.emissiveMap.value = material.emissiveMap;\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv\n\n          defines.USE_ROUGHNESSMAP = '';\n        }\n\n        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n          delete defines.USE_GLOSSINESSMAP;\n          delete defines.USE_ROUGHNESSMAP;\n        }\n      }\n    };\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize,\n        offset = index * valueSize * 3 + valueSize;\n\n    for (var i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  };\n\n  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    var result = this.resultBuffer;\n    var values = this.sampleValues;\n    var stride = this.valueSize;\n    var stride2 = stride * 2;\n    var stride3 = stride * 3;\n    var td = t1 - t0;\n    var p = (t - t0) / td;\n    var pp = p * p;\n    var ppp = pp * p;\n    var offset1 = i1 * stride3;\n    var offset0 = offset1 - stride3;\n    var s2 = -2 * ppp + 3 * pp;\n    var s3 = ppp - pp;\n    var s0 = 1 - s2;\n    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (var i = 0; i !== stride; i++) {\n      var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  var WEBGL_TYPE = {\n    5126: Number,\n    //35674: THREE.Matrix2,\n    35675: THREE.Matrix3,\n    35676: THREE.Matrix4,\n    35664: THREE.Vector2,\n    35665: THREE.Vector3,\n    35666: THREE.Vector4,\n    35678: THREE.Texture\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: THREE.NearestFilter,\n    9729: THREE.LinearFilter,\n    9984: THREE.NearestMipMapNearestFilter,\n    9985: THREE.LinearMipMapNearestFilter,\n    9986: THREE.NearestMipMapLinearFilter,\n    9987: THREE.LinearMipMapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: THREE.ClampToEdgeWrapping,\n    33648: THREE.MirroredRepeatWrapping,\n    10497: THREE.RepeatWrapping\n  };\n  var WEBGL_SIDES = {\n    1028: THREE.BackSide,\n    // Culling front\n    1029: THREE.FrontSide // Culling back\n    //1032: THREE.NoSide   // Culling front and back, what to do?\n\n  };\n  var WEBGL_DEPTH_FUNCS = {\n    512: THREE.NeverDepth,\n    513: THREE.LessDepth,\n    514: THREE.EqualDepth,\n    515: THREE.LessEqualDepth,\n    516: THREE.GreaterEqualDepth,\n    517: THREE.NotEqualDepth,\n    518: THREE.GreaterEqualDepth,\n    519: THREE.AlwaysDepth\n  };\n  var WEBGL_BLEND_EQUATIONS = {\n    32774: THREE.AddEquation,\n    32778: THREE.SubtractEquation,\n    32779: THREE.ReverseSubtractEquation\n  };\n  var WEBGL_BLEND_FUNCS = {\n    0: THREE.ZeroFactor,\n    1: THREE.OneFactor,\n    768: THREE.SrcColorFactor,\n    769: THREE.OneMinusSrcColorFactor,\n    770: THREE.SrcAlphaFactor,\n    771: THREE.OneMinusSrcAlphaFactor,\n    772: THREE.DstAlphaFactor,\n    773: THREE.OneMinusDstAlphaFactor,\n    774: THREE.DstColorFactor,\n    775: THREE.OneMinusDstColorFactor,\n    776: THREE.SrcAlphaSaturateFactor // The followings are not supported by Three.js yet\n    //32769: CONSTANT_COLOR,\n    //32770: ONE_MINUS_CONSTANT_COLOR,\n    //32771: CONSTANT_ALPHA,\n    //32772: ONE_MINUS_CONSTANT_COLOR\n\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex'\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  var INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: THREE.InterpolateLinear,\n    STEP: THREE.InterpolateDiscrete\n  };\n  var STATES_ENABLES = {\n    2884: 'CULL_FACE',\n    2929: 'DEPTH_TEST',\n    3042: 'BLEND',\n    3089: 'SCISSOR_TEST',\n    32823: 'POLYGON_OFFSET_FILL',\n    32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n  };\n  var ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  var MIME_TYPE_FORMATS = {\n    'image/png': THREE.RGBAFormat,\n    'image/jpeg': THREE.RGBFormat\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Absolute URL http://,https://,//\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n\n  var defaultMaterial;\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n   */\n\n  function createDefaultMaterial() {\n    defaultMaterial = defaultMaterial || new THREE.MeshStandardMaterial({\n      color: 0xFFFFFF,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: THREE.FrontSide\n    });\n    return defaultMaterial;\n  }\n\n  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for (var name in objectDef.extensions) {\n      if (knownExtensions[name] === undefined) {\n        object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n        object.userData.gltfExtensions[name] = objectDef.extensions[name];\n      }\n    }\n  }\n  /**\n   * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n   * @param {GLTF.definition} gltfDef\n   */\n\n\n  function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n      if (_typeof(gltfDef.extras) === 'object') {\n        object.userData = gltfDef.extras;\n      } else {\n        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n      }\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n   *\n   * @param {THREE.BufferGeometry} geometry\n   * @param {Array<GLTF.Target>} targets\n   * @param {GLTFParser} parser\n   * @return {Promise<THREE.BufferGeometry>}\n   */\n\n\n  function addMorphTargets(geometry, targets, parser) {\n    var hasMorphPosition = false;\n    var hasMorphNormal = false;\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n\n    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n    var pendingPositionAccessors = [];\n    var pendingNormalAccessors = [];\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n\n      if (hasMorphPosition) {\n        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n        pendingPositionAccessors.push(pendingAccessor);\n      }\n\n      if (hasMorphNormal) {\n        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n        pendingNormalAccessors.push(pendingAccessor);\n      }\n    }\n\n    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n      var morphPositions = accessors[0];\n      var morphNormals = accessors[1]; // Clone morph target accessors before modifying them.\n\n      for (var i = 0, il = morphPositions.length; i < il; i++) {\n        if (geometry.attributes.position === morphPositions[i]) continue;\n        morphPositions[i] = cloneBufferAttribute(morphPositions[i]);\n      }\n\n      for (var i = 0, il = morphNormals.length; i < il; i++) {\n        if (geometry.attributes.normal === morphNormals[i]) continue;\n        morphNormals[i] = cloneBufferAttribute(morphNormals[i]);\n      }\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n        var target = targets[i];\n        var attributeName = 'morphTarget' + i;\n\n        if (hasMorphPosition) {\n          // Three.js morph position is absolute value. The formula is\n          //   basePosition\n          //     + weight0 * ( morphPosition0 - basePosition )\n          //     + weight1 * ( morphPosition1 - basePosition )\n          //     ...\n          // while the glTF one is relative\n          //   basePosition\n          //     + weight0 * glTFmorphPosition0\n          //     + weight1 * glTFmorphPosition1\n          //     ...\n          // then we need to convert from relative to absolute here.\n          if (target.POSITION !== undefined) {\n            var positionAttribute = morphPositions[i];\n            positionAttribute.name = attributeName;\n            var position = geometry.attributes.position;\n\n            for (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n              positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n            }\n          }\n        }\n\n        if (hasMorphNormal) {\n          // see target.POSITION's comment\n          if (target.NORMAL !== undefined) {\n            var normalAttribute = morphNormals[i];\n            normalAttribute.name = attributeName;\n            var normal = geometry.attributes.normal;\n\n            for (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n              normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));\n            }\n          }\n        }\n      }\n\n      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n      return geometry;\n    });\n  }\n  /**\n   * @param {THREE.Mesh} mesh\n   * @param {GLTF.Mesh} meshDef\n   */\n\n\n  function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n\n    if (meshDef.weights !== undefined) {\n      for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      var targetNames = meshDef.extras.targetNames;\n\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n\n        for (var i = 0, il = targetNames.length; i < il; i++) {\n          mesh.morphTargetDictionary[targetNames[i]] = i;\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n\n  function isObjectEqual(a, b) {\n    if (Object.keys(a).length !== Object.keys(b).length) return false;\n\n    for (var key in a) {\n      if (a[key] !== b[key]) return false;\n    }\n\n    return true;\n  }\n\n  function createPrimitiveKey(primitiveDef) {\n    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    var geometryKey;\n\n    if (dracoExtension) {\n      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n    } else {\n      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n    }\n\n    return geometryKey;\n  }\n\n  function createAttributesKey(attributes) {\n    var attributesKey = '';\n    var keys = Object.keys(attributes).sort();\n\n    for (var i = 0, il = keys.length; i < il; i++) {\n      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n    }\n\n    return attributesKey;\n  }\n\n  function cloneBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) {\n      var count = attribute.count;\n      var itemSize = attribute.itemSize;\n      var array = attribute.array.slice(0, count * itemSize);\n\n      for (var i = 0, j = 0; i < count; ++i) {\n        array[j++] = attribute.getX(i);\n        if (itemSize >= 2) array[j++] = attribute.getY(i);\n        if (itemSize >= 3) array[j++] = attribute.getZ(i);\n        if (itemSize >= 4) array[j++] = attribute.getW(i);\n      }\n\n      return new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n    }\n\n    return attribute.clone();\n  }\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry(); // BufferGeometry caching\n\n    this.primitiveCache = {};\n    this.textureLoader = new THREE.TextureLoader(this.options.manager);\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.fileLoader = new THREE.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n  }\n\n  GLTFParser.prototype.parse = function (onLoad, onError) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this.markDefs();\n    Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {\n      var result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      onLoad(result);\n    })[\"catch\"](onError);\n  };\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  GLTFParser.prototype.markDefs = function () {\n    var nodeDefs = this.json.nodes || [];\n    var skinDefs = this.json.skins || [];\n    var meshDefs = this.json.meshes || [];\n    var meshReferences = {};\n    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      var joints = skinDefs[skinIndex].joints;\n\n      for (var i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n    // avoid having more than one THREE.Mesh with the same name, count\n    // references and rename instances below.\n    //\n    // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\n\n    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      var nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        if (meshReferences[nodeDef.mesh] === undefined) {\n          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n        }\n\n        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n    }\n\n    this.json.meshReferences = meshReferences;\n    this.json.meshUses = meshUses;\n  };\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  GLTFParser.prototype.getDependency = function (type, index) {\n    var cacheKey = type + ':' + index;\n    var dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this.loadMesh(index);\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this.loadBufferView(index);\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this.loadMaterial(index);\n          break;\n\n        case 'texture':\n          dependency = this.loadTexture(index);\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        case 'light':\n          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  };\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  GLTFParser.prototype.getDependencies = function (type) {\n    var dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      var parser = this;\n      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n    var bufferDef = this.json.buffers[bufferIndex];\n    var loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    var options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n    var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      var byteLength = bufferViewDef.byteLength || 0;\n      var byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n   */\n\n\n  GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n    var parser = this;\n    var json = this.json;\n    var accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    var pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      var bufferView = bufferViews[0];\n      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      var itemBytes = elementBytes * itemSize;\n      var byteOffset = accessorDef.byteOffset || 0;\n      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      var normalized = accessorDef.normalized === true;\n      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n        var ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          // Use the full buffer if it's interleaved.\n          array = new TypedArray(bufferView); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute.setArray(bufferAttribute.array.slice());\n        }\n\n        for (var i = 0, il = sparseIndices.length; i < il; i++) {\n          var index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  GLTFParser.prototype.loadTexture = function (textureIndex) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n    var URL = window.URL || window.webkitURL;\n    var textureDef = json.textures[textureIndex];\n    var textureExtensions = textureDef.extensions || {};\n    var source;\n\n    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n    } else {\n      source = json.images[textureDef.source];\n    }\n\n    var sourceURI = source.uri;\n    var isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        var blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      // Load Texture resource.\n      var loader = THREE.Loader.Handlers.get(sourceURI);\n\n      if (!loader) {\n        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n      }\n\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name !== undefined) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.\n\n      if (source.mimeType in MIME_TYPE_FORMATS) {\n        texture.format = MIME_TYPE_FORMATS[source.mimeType];\n      }\n\n      var samplers = json.samplers || {};\n      var sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n      return texture;\n    });\n  };\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise}\n   */\n\n\n  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n    var parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      switch (mapName) {\n        case 'aoMap':\n        case 'emissiveMap':\n        case 'metalnessMap':\n        case 'normalMap':\n        case 'roughnessMap':\n          texture.format = THREE.RGBFormat;\n          break;\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n        }\n      }\n\n      materialParams[mapName] = texture;\n    });\n  };\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accomodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n    var geometry = mesh.geometry;\n    var material = mesh.material;\n    var extensions = this.extensions;\n    var useVertexTangents = geometry.attributes.tangent !== undefined;\n    var useVertexColors = geometry.attributes.color !== undefined;\n    var useFlatShading = geometry.attributes.normal === undefined;\n    var useSkinning = mesh.isSkinnedMesh === true;\n    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n    if (mesh.isPoints) {\n      var cacheKey = 'PointsMaterial:' + material.uuid;\n      var pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new THREE.PointsMaterial();\n        THREE.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      var cacheKey = 'LineBasicMaterial:' + material.uuid;\n      var lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new THREE.LineBasicMaterial();\n        THREE.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useSkinning) cacheKey += 'skinning:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      if (useMorphTargets) cacheKey += 'morph-targets:';\n      if (useMorphNormals) cacheKey += 'morph-normals:';\n      var cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();\n        if (useSkinning) cachedMaterial.skinning = true;\n        if (useVertexTangents) cachedMaterial.vertexTangents = true;\n        if (useVertexColors) cachedMaterial.vertexColors = THREE.VertexColors;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\n        this.cache.add(cacheKey, cachedMaterial);\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n      geometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n\n    if (material.isGLTFSpecularGlossinessMaterial) {\n      // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n      mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n    }\n\n    mesh.material = material;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<THREE.Material>}\n   */\n\n\n  GLTFParser.prototype.loadMaterial = function (materialIndex) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions;\n    var materialDef = json.materials[materialIndex];\n    var materialType;\n    var materialParams = {};\n    var materialExtensions = materialDef.extensions || {};\n    var pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType(materialDef);\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType(materialDef);\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      materialType = THREE.MeshStandardMaterial;\n      var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = THREE.DoubleSide;\n    }\n\n    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n      materialParams.normalScale = new THREE.Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    return Promise.all(pending).then(function () {\n      var material;\n\n      if (materialType === THREE.ShaderMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name !== undefined) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = THREE.sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n      if (material.specularMap) material.specularMap.encoding = THREE.sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  };\n  /**\n   * @param {THREE.BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   * @return {Promise<THREE.BufferGeometry>}\n   */\n\n\n  function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var pending = [];\n\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n        geometry.addAttribute(attributeName, accessor);\n      });\n    }\n\n    for (var gltfAttributeName in attributes) {\n      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n      if (threeAttributeName in geometry.attributes) continue;\n      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n      pending.push(accessor);\n    }\n\n    assignExtrasToUserData(geometry, primitiveDef);\n    return Promise.all(pending).then(function () {\n      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<THREE.BufferGeometry>>}\n   */\n\n\n  GLTFParser.prototype.loadGeometries = function (primitives) {\n    var parser = this;\n    var extensions = this.extensions;\n    var cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var primitive = primitives[i];\n      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      var cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        var geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n   */\n\n\n  GLTFParser.prototype.loadMesh = function (meshIndex) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions;\n    var meshDef = json.meshes[meshIndex];\n    var primitives = meshDef.primitives;\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var material = primitives[i].material === undefined ? createDefaultMaterial() : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    return Promise.all(pending).then(function (originalMaterials) {\n      return parser.loadGeometries(primitives).then(function (geometries) {\n        var meshes = [];\n\n        for (var i = 0, il = geometries.length; i < il; i++) {\n          var geometry = geometries[i];\n          var primitive = primitives[i]; // 1. create Mesh\n\n          var mesh;\n          var material = originalMaterials[i];\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n            // .isSkinnedMesh isn't in glTF spec. See .markDefs()\n            mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);\n            if (mesh.isSkinnedMesh === true) mesh.normalizeSkinWeights(); // #15319\n\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n              mesh.drawMode = THREE.TriangleStripDrawMode;\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n              mesh.drawMode = THREE.TriangleFanDrawMode;\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            mesh = new THREE.LineSegments(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n            mesh = new THREE.Line(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n            mesh = new THREE.LineLoop(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n            mesh = new THREE.Points(geometry, material);\n          } else {\n            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n          }\n\n          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n            updateMorphTargets(mesh, meshDef);\n          }\n\n          mesh.name = meshDef.name || 'mesh_' + meshIndex;\n          if (geometries.length > 1) mesh.name += '_' + i;\n          assignExtrasToUserData(mesh, meshDef);\n          parser.assignFinalMaterial(mesh);\n          meshes.push(mesh);\n        }\n\n        if (meshes.length === 1) {\n          return meshes[0];\n        }\n\n        var group = new THREE.Group();\n\n        for (var i = 0, il = meshes.length; i < il; i++) {\n          group.add(meshes[i]);\n        }\n\n        return group;\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  GLTFParser.prototype.loadCamera = function (cameraIndex) {\n    var camera;\n    var cameraDef = this.json.cameras[cameraIndex];\n    var params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name !== undefined) camera.name = cameraDef.name;\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.loadSkin = function (skinIndex) {\n    var skinDef = this.json.skins[skinIndex];\n    var skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<THREE.AnimationClip>}\n   */\n\n\n  GLTFParser.prototype.loadAnimation = function (animationIndex) {\n    var json = this.json;\n    var animationDef = json.animations[animationIndex];\n    var pendingNodes = [];\n    var pendingInputAccessors = [];\n    var pendingOutputAccessors = [];\n    var pendingSamplers = [];\n    var pendingTargets = [];\n\n    for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n      var channel = animationDef.channels[i];\n      var sampler = animationDef.samplers[channel.sampler];\n      var target = channel.target;\n      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      var nodes = dependencies[0];\n      var inputAccessors = dependencies[1];\n      var outputAccessors = dependencies[2];\n      var samplers = dependencies[3];\n      var targets = dependencies[4];\n      var tracks = [];\n\n      for (var i = 0, il = nodes.length; i < il; i++) {\n        var node = nodes[i];\n        var inputAccessor = inputAccessors[i];\n        var outputAccessor = outputAccessors[i];\n        var sampler = samplers[i];\n        var target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        var TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = THREE.NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = THREE.VectorKeyframeTrack;\n            break;\n        }\n\n        var targetName = node.name ? node.name : node.uuid;\n        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n        var targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          // Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        for (var j = 0, jl = targetNames.length; j < jl; j++) {\n          var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputAccessor.array, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n      return new THREE.AnimationClip(name, undefined, tracks);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<THREE.Object3D>}\n   */\n\n\n  GLTFParser.prototype.loadNode = function (nodeIndex) {\n    var json = this.json;\n    var extensions = this.extensions;\n    var parser = this;\n    var meshReferences = json.meshReferences;\n    var meshUses = json.meshUses;\n    var nodeDef = json.nodes[nodeIndex];\n    return function () {\n      // .isBone isn't in glTF spec. See .markDefs\n      if (nodeDef.isBone === true) {\n        return Promise.resolve(new THREE.Bone());\n      } else if (nodeDef.mesh !== undefined) {\n        return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n          var node;\n\n          if (meshReferences[nodeDef.mesh] > 1) {\n            var instanceNum = meshUses[nodeDef.mesh]++;\n            node = mesh.clone();\n            node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness\n\n            node.onBeforeRender = mesh.onBeforeRender;\n\n            for (var i = 0, il = node.children.length; i < il; i++) {\n              node.children[i].name += '_instance_' + instanceNum;\n              node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;\n            }\n          } else {\n            node = mesh;\n          } // if weights are provided on the node, override weights on the mesh.\n\n\n          if (nodeDef.weights !== undefined) {\n            node.traverse(function (o) {\n              if (!o.isMesh) return;\n\n              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n                o.morphTargetInfluences[i] = nodeDef.weights[i];\n              }\n            });\n          }\n\n          return node;\n        });\n      } else if (nodeDef.camera !== undefined) {\n        return parser.getDependency('camera', nodeDef.camera);\n      } else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n        return parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light);\n      } else {\n        return Promise.resolve(new THREE.Object3D());\n      }\n    }().then(function (node) {\n      if (nodeDef.name !== undefined) {\n        node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        var matrix = new THREE.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      return node;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<THREE.Scene>}\n   */\n\n\n  GLTFParser.prototype.loadScene = function () {\n    // scene node hierachy builder\n    function buildNodeHierachy(nodeId, parentObject, json, parser) {\n      var nodeDef = json.nodes[nodeId];\n      return parser.getDependency('node', nodeId).then(function (node) {\n        if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n        var skinEntry;\n        return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n          skinEntry = skin;\n          var pendingJoints = [];\n\n          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n          }\n\n          return Promise.all(pendingJoints);\n        }).then(function (jointNodes) {\n          var meshes = node.isGroup === true ? node.children : [node];\n\n          for (var i = 0, il = meshes.length; i < il; i++) {\n            var mesh = meshes[i];\n            var bones = [];\n            var boneInverses = [];\n\n            for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n              var jointNode = jointNodes[j];\n\n              if (jointNode) {\n                bones.push(jointNode);\n                var mat = new THREE.Matrix4();\n\n                if (skinEntry.inverseBindMatrices !== undefined) {\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                }\n\n                boneInverses.push(mat);\n              } else {\n                console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n              }\n            }\n\n            mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n          }\n\n          return node;\n        });\n      }).then(function (node) {\n        // build node hierachy\n        parentObject.add(node);\n        var pending = [];\n\n        if (nodeDef.children) {\n          var children = nodeDef.children;\n\n          for (var i = 0, il = children.length; i < il; i++) {\n            var child = children[i];\n            pending.push(buildNodeHierachy(child, node, json, parser));\n          }\n        }\n\n        return Promise.all(pending);\n      });\n    }\n\n    return function loadScene(sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      var parser = this;\n      var scene = new THREE.Scene();\n      if (sceneDef.name !== undefined) scene.name = sceneDef.name;\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      var nodeIds = sceneDef.nodes || [];\n      var pending = [];\n\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    };\n  }();\n\n  return GLTFLoader;\n}());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9HTFRGTG9hZGVyLmpzPzNjNjkiXSwibmFtZXMiOlsiVEhSRUUiLCJHTFRGTG9hZGVyIiwibWFuYWdlciIsInVuZGVmaW5lZCIsIkRlZmF1bHRMb2FkaW5nTWFuYWdlciIsImRyYWNvTG9hZGVyIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJjcm9zc09yaWdpbiIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsInNjb3BlIiwicmVzb3VyY2VQYXRoIiwicGF0aCIsIkxvYWRlclV0aWxzIiwiZXh0cmFjdFVybEJhc2UiLCJpdGVtU3RhcnQiLCJfb25FcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJpdGVtRXJyb3IiLCJpdGVtRW5kIiwibG9hZGVyIiwiRmlsZUxvYWRlciIsInNldFBhdGgiLCJzZXRSZXNwb25zZVR5cGUiLCJkYXRhIiwicGFyc2UiLCJnbHRmIiwic2V0Q3Jvc3NPcmlnaW4iLCJ2YWx1ZSIsInNldFJlc291cmNlUGF0aCIsInNldERSQUNPTG9hZGVyIiwiY29udGVudCIsImV4dGVuc2lvbnMiLCJtYWdpYyIsImRlY29kZVRleHQiLCJVaW50OEFycmF5IiwiQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMiLCJFWFRFTlNJT05TIiwiS0hSX0JJTkFSWV9HTFRGIiwiR0xURkJpbmFyeUV4dGVuc2lvbiIsImpzb24iLCJKU09OIiwiYXNzZXQiLCJ2ZXJzaW9uIiwiRXJyb3IiLCJleHRlbnNpb25zVXNlZCIsImkiLCJsZW5ndGgiLCJleHRlbnNpb25OYW1lIiwiZXh0ZW5zaW9uc1JlcXVpcmVkIiwiS0hSX0xJR0hUU19QVU5DVFVBTCIsIkdMVEZMaWdodHNFeHRlbnNpb24iLCJLSFJfTUFURVJJQUxTX1VOTElUIiwiR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uIiwiS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyIsIkdMVEZNYXRlcmlhbHNQYnJTcGVjdWxhckdsb3NzaW5lc3NFeHRlbnNpb24iLCJLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiIsIkdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiIsIk1TRlRfVEVYVFVSRV9ERFMiLCJHTFRGVGV4dHVyZUREU0V4dGVuc2lvbiIsIktIUl9URVhUVVJFX1RSQU5TRk9STSIsIkdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIiwiaW5kZXhPZiIsIndhcm4iLCJwYXJzZXIiLCJHTFRGUGFyc2VyIiwiR0xURlJlZ2lzdHJ5Iiwib2JqZWN0cyIsImdldCIsImtleSIsImFkZCIsIm9iamVjdCIsInJlbW92ZSIsInJlbW92ZUFsbCIsIkREU0xvYWRlciIsIm5hbWUiLCJkZHNMb2FkZXIiLCJleHRlbnNpb24iLCJsaWdodERlZnMiLCJsaWdodHMiLCJsb2FkTGlnaHQiLCJsaWdodEluZGV4IiwibGlnaHREZWYiLCJsaWdodE5vZGUiLCJjb2xvciIsIkNvbG9yIiwiZnJvbUFycmF5IiwicmFuZ2UiLCJ0eXBlIiwiRGlyZWN0aW9uYWxMaWdodCIsInRhcmdldCIsInBvc2l0aW9uIiwic2V0IiwiUG9pbnRMaWdodCIsImRpc3RhbmNlIiwiU3BvdExpZ2h0Iiwic3BvdCIsImlubmVyQ29uZUFuZ2xlIiwib3V0ZXJDb25lQW5nbGUiLCJNYXRoIiwiUEkiLCJhbmdsZSIsInBlbnVtYnJhIiwiZGVjYXkiLCJpbnRlbnNpdHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldE1hdGVyaWFsVHlwZSIsIm1hdGVyaWFsIiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJleHRlbmRQYXJhbXMiLCJtYXRlcmlhbFBhcmFtcyIsInBlbmRpbmciLCJvcGFjaXR5IiwibWV0YWxsaWNSb3VnaG5lc3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyIsIkFycmF5IiwiaXNBcnJheSIsImJhc2VDb2xvckZhY3RvciIsImFycmF5IiwiYmFzZUNvbG9yVGV4dHVyZSIsInB1c2giLCJhc3NpZ25UZXh0dXJlIiwiYWxsIiwiQklOQVJZX0VYVEVOU0lPTl9CVUZGRVJfTkFNRSIsIkJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCIsIkJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMiLCJCSU4iLCJib2R5IiwiaGVhZGVyVmlldyIsIkRhdGFWaWV3IiwiaGVhZGVyIiwic2xpY2UiLCJnZXRVaW50MzIiLCJjaHVua1ZpZXciLCJjaHVua0luZGV4IiwiYnl0ZUxlbmd0aCIsImNodW5rTGVuZ3RoIiwiY2h1bmtUeXBlIiwiY29udGVudEFycmF5IiwiYnl0ZU9mZnNldCIsImRlY29kZVByaW1pdGl2ZSIsInByaW1pdGl2ZSIsImJ1ZmZlclZpZXdJbmRleCIsImJ1ZmZlclZpZXciLCJnbHRmQXR0cmlidXRlTWFwIiwiYXR0cmlidXRlcyIsInRocmVlQXR0cmlidXRlTWFwIiwiYXR0cmlidXRlTm9ybWFsaXplZE1hcCIsImF0dHJpYnV0ZVR5cGVNYXAiLCJhdHRyaWJ1dGVOYW1lIiwidGhyZWVBdHRyaWJ1dGVOYW1lIiwiQVRUUklCVVRFUyIsInRvTG93ZXJDYXNlIiwiYWNjZXNzb3JEZWYiLCJhY2Nlc3NvcnMiLCJjb21wb25lbnRUeXBlIiwiV0VCR0xfQ09NUE9ORU5UX1RZUEVTIiwibm9ybWFsaXplZCIsImdldERlcGVuZGVuY3kiLCJ0aGVuIiwiZGVjb2RlRHJhY29GaWxlIiwiZ2VvbWV0cnkiLCJhdHRyaWJ1dGUiLCJleHRlbmRUZXh0dXJlIiwidGV4dHVyZSIsInRyYW5zZm9ybSIsImNsb25lIiwib2Zmc2V0Iiwicm90YXRpb24iLCJzY2FsZSIsInJlcGVhdCIsInRleENvb3JkIiwibmVlZHNVcGRhdGUiLCJzcGVjdWxhckdsb3NzaW5lc3NQYXJhbXMiLCJTaGFkZXJNYXRlcmlhbCIsInBhcmFtcyIsInBiclNwZWN1bGFyR2xvc3NpbmVzcyIsInNoYWRlciIsIlNoYWRlckxpYiIsInVuaWZvcm1zIiwiVW5pZm9ybXNVdGlscyIsInNwZWN1bGFyTWFwUGFyc0ZyYWdtZW50Q2h1bmsiLCJqb2luIiwiZ2xvc3NpbmVzc01hcFBhcnNGcmFnbWVudENodW5rIiwic3BlY3VsYXJNYXBGcmFnbWVudENodW5rIiwiZ2xvc3NpbmVzc01hcEZyYWdtZW50Q2h1bmsiLCJsaWdodFBoeXNpY2FsRnJhZ21lbnRDaHVuayIsImZyYWdtZW50U2hhZGVyIiwicmVwbGFjZSIsInJvdWdobmVzcyIsIm1ldGFsbmVzcyIsInJvdWdobmVzc01hcCIsIm1ldGFsbmVzc01hcCIsInNwZWN1bGFyIiwic2V0SGV4IiwiZ2xvc3NpbmVzcyIsInNwZWN1bGFyTWFwIiwiZ2xvc3NpbmVzc01hcCIsInZlcnRleFNoYWRlciIsImRlZmluZXMiLCJkaWZmdXNlRmFjdG9yIiwiZGlmZnVzZVRleHR1cmUiLCJlbWlzc2l2ZSIsImdsb3NzaW5lc3NGYWN0b3IiLCJzcGVjdWxhckZhY3RvciIsInNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUiLCJzcGVjR2xvc3NNYXBEZWYiLCJjcmVhdGVNYXRlcmlhbCIsImZvZyIsInRyYW5zcGFyZW50IiwiaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwiLCJtYXAiLCJsaWdodE1hcCIsImxpZ2h0TWFwSW50ZW5zaXR5IiwiYW9NYXAiLCJhb01hcEludGVuc2l0eSIsImVtaXNzaXZlSW50ZW5zaXR5IiwiZW1pc3NpdmVNYXAiLCJidW1wTWFwIiwiYnVtcFNjYWxlIiwibm9ybWFsTWFwIiwibm9ybWFsU2NhbGUiLCJkaXNwbGFjZW1lbnRNYXAiLCJkaXNwbGFjZW1lbnRTY2FsZSIsImRpc3BsYWNlbWVudEJpYXMiLCJhbHBoYU1hcCIsImVudk1hcCIsImVudk1hcEludGVuc2l0eSIsInJlZnJhY3Rpb25SYXRpbyIsImRlcml2YXRpdmVzIiwiY2xvbmVNYXRlcmlhbCIsInNvdXJjZSIsImlsIiwicmVmcmVzaFVuaWZvcm1zIiwicmVuZGVyZXIiLCJzY2VuZSIsImNhbWVyYSIsImdyb3VwIiwiZGlmZnVzZSIsImNvcHkiLCJtdWx0aXBseVNjYWxhciIsInV2U2NhbGVNYXAiLCJpc1dlYkdMUmVuZGVyVGFyZ2V0IiwibWF0cml4QXV0b1VwZGF0ZSIsInVwZGF0ZU1hdHJpeCIsInV2VHJhbnNmb3JtIiwibWF0cml4IiwiZmxpcEVudk1hcCIsImlzQ3ViZVRleHR1cmUiLCJyZWZsZWN0aXZpdHkiLCJtYXhNaXBMZXZlbCIsInByb3BlcnRpZXMiLCJfX21heE1pcExldmVsIiwiVVNFX0dMT1NTSU5FU1NNQVAiLCJVU0VfUk9VR0hORVNTTUFQIiwiR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQiLCJwYXJhbWV0ZXJQb3NpdGlvbnMiLCJzYW1wbGVWYWx1ZXMiLCJzYW1wbGVTaXplIiwicmVzdWx0QnVmZmVyIiwiSW50ZXJwb2xhbnQiLCJjYWxsIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29weVNhbXBsZVZhbHVlXyIsImluZGV4IiwicmVzdWx0IiwidmFsdWVzIiwidmFsdWVTaXplIiwiYmVmb3JlU3RhcnRfIiwiYWZ0ZXJFbmRfIiwiaW50ZXJwb2xhdGVfIiwiaTEiLCJ0MCIsInQiLCJ0MSIsInN0cmlkZSIsInN0cmlkZTIiLCJzdHJpZGUzIiwidGQiLCJwIiwicHAiLCJwcHAiLCJvZmZzZXQxIiwib2Zmc2V0MCIsInMyIiwiczMiLCJzMCIsInMxIiwicDAiLCJtMCIsInAxIiwibTEiLCJXRUJHTF9DT05TVEFOVFMiLCJGTE9BVCIsIkZMT0FUX01BVDMiLCJGTE9BVF9NQVQ0IiwiRkxPQVRfVkVDMiIsIkZMT0FUX1ZFQzMiLCJGTE9BVF9WRUM0IiwiTElORUFSIiwiUkVQRUFUIiwiU0FNUExFUl8yRCIsIlBPSU5UUyIsIkxJTkVTIiwiTElORV9MT09QIiwiTElORV9TVFJJUCIsIlRSSUFOR0xFUyIsIlRSSUFOR0xFX1NUUklQIiwiVFJJQU5HTEVfRkFOIiwiVU5TSUdORURfQllURSIsIlVOU0lHTkVEX1NIT1JUIiwiV0VCR0xfVFlQRSIsIk51bWJlciIsIk1hdHJpeDMiLCJNYXRyaXg0IiwiVmVjdG9yMiIsIlZlY3RvcjMiLCJWZWN0b3I0IiwiVGV4dHVyZSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiV0VCR0xfRklMVEVSUyIsIk5lYXJlc3RGaWx0ZXIiLCJMaW5lYXJGaWx0ZXIiLCJOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciIsIkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIiLCJOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyIiwiTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyIiwiV0VCR0xfV1JBUFBJTkdTIiwiQ2xhbXBUb0VkZ2VXcmFwcGluZyIsIk1pcnJvcmVkUmVwZWF0V3JhcHBpbmciLCJSZXBlYXRXcmFwcGluZyIsIldFQkdMX1NJREVTIiwiQmFja1NpZGUiLCJGcm9udFNpZGUiLCJXRUJHTF9ERVBUSF9GVU5DUyIsIk5ldmVyRGVwdGgiLCJMZXNzRGVwdGgiLCJFcXVhbERlcHRoIiwiTGVzc0VxdWFsRGVwdGgiLCJHcmVhdGVyRXF1YWxEZXB0aCIsIk5vdEVxdWFsRGVwdGgiLCJBbHdheXNEZXB0aCIsIldFQkdMX0JMRU5EX0VRVUFUSU9OUyIsIkFkZEVxdWF0aW9uIiwiU3VidHJhY3RFcXVhdGlvbiIsIlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uIiwiV0VCR0xfQkxFTkRfRlVOQ1MiLCJaZXJvRmFjdG9yIiwiT25lRmFjdG9yIiwiU3JjQ29sb3JGYWN0b3IiLCJPbmVNaW51c1NyY0NvbG9yRmFjdG9yIiwiU3JjQWxwaGFGYWN0b3IiLCJPbmVNaW51c1NyY0FscGhhRmFjdG9yIiwiRHN0QWxwaGFGYWN0b3IiLCJPbmVNaW51c0RzdEFscGhhRmFjdG9yIiwiRHN0Q29sb3JGYWN0b3IiLCJPbmVNaW51c0RzdENvbG9yRmFjdG9yIiwiU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciIsIldFQkdMX1RZUEVfU0laRVMiLCJQT1NJVElPTiIsIk5PUk1BTCIsIlRBTkdFTlQiLCJURVhDT09SRF8wIiwiVEVYQ09PUkRfMSIsIkNPTE9SXzAiLCJXRUlHSFRTXzAiLCJKT0lOVFNfMCIsIlBBVEhfUFJPUEVSVElFUyIsInRyYW5zbGF0aW9uIiwid2VpZ2h0cyIsIklOVEVSUE9MQVRJT04iLCJDVUJJQ1NQTElORSIsIkludGVycG9sYXRlTGluZWFyIiwiU1RFUCIsIkludGVycG9sYXRlRGlzY3JldGUiLCJTVEFURVNfRU5BQkxFUyIsIkFMUEhBX01PREVTIiwiT1BBUVVFIiwiTUFTSyIsIkJMRU5EIiwiTUlNRV9UWVBFX0ZPUk1BVFMiLCJSR0JBRm9ybWF0IiwiUkdCRm9ybWF0IiwicmVzb2x2ZVVSTCIsInRlc3QiLCJkZWZhdWx0TWF0ZXJpYWwiLCJjcmVhdGVEZWZhdWx0TWF0ZXJpYWwiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsImRlcHRoVGVzdCIsInNpZGUiLCJhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEiLCJrbm93bkV4dGVuc2lvbnMiLCJvYmplY3REZWYiLCJ1c2VyRGF0YSIsImdsdGZFeHRlbnNpb25zIiwiYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSIsImdsdGZEZWYiLCJleHRyYXMiLCJhZGRNb3JwaFRhcmdldHMiLCJ0YXJnZXRzIiwiaGFzTW9ycGhQb3NpdGlvbiIsImhhc01vcnBoTm9ybWFsIiwicGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzIiwicGVuZGluZ05vcm1hbEFjY2Vzc29ycyIsInBlbmRpbmdBY2Nlc3NvciIsIm5vcm1hbCIsIm1vcnBoUG9zaXRpb25zIiwibW9ycGhOb3JtYWxzIiwiY2xvbmVCdWZmZXJBdHRyaWJ1dGUiLCJwb3NpdGlvbkF0dHJpYnV0ZSIsImoiLCJqbCIsImNvdW50Iiwic2V0WFlaIiwiZ2V0WCIsImdldFkiLCJnZXRaIiwibm9ybWFsQXR0cmlidXRlIiwibW9ycGhBdHRyaWJ1dGVzIiwidXBkYXRlTW9ycGhUYXJnZXRzIiwibWVzaCIsIm1lc2hEZWYiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJ0YXJnZXROYW1lcyIsIm1vcnBoVGFyZ2V0RGljdGlvbmFyeSIsImlzT2JqZWN0RXF1YWwiLCJhIiwiYiIsImtleXMiLCJjcmVhdGVQcmltaXRpdmVLZXkiLCJwcmltaXRpdmVEZWYiLCJkcmFjb0V4dGVuc2lvbiIsImdlb21ldHJ5S2V5IiwiaW5kaWNlcyIsImNyZWF0ZUF0dHJpYnV0ZXNLZXkiLCJtb2RlIiwiYXR0cmlidXRlc0tleSIsInNvcnQiLCJpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiaXRlbVNpemUiLCJnZXRXIiwiQnVmZmVyQXR0cmlidXRlIiwib3B0aW9ucyIsImNhY2hlIiwicHJpbWl0aXZlQ2FjaGUiLCJ0ZXh0dXJlTG9hZGVyIiwiVGV4dHVyZUxvYWRlciIsImZpbGVMb2FkZXIiLCJtYXJrRGVmcyIsImdldERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsInNjZW5lcyIsImFuaW1hdGlvbnMiLCJjYW1lcmFzIiwibm9kZURlZnMiLCJub2RlcyIsInNraW5EZWZzIiwic2tpbnMiLCJtZXNoRGVmcyIsIm1lc2hlcyIsIm1lc2hSZWZlcmVuY2VzIiwibWVzaFVzZXMiLCJza2luSW5kZXgiLCJza2luTGVuZ3RoIiwiam9pbnRzIiwiaXNCb25lIiwibm9kZUluZGV4Iiwibm9kZUxlbmd0aCIsIm5vZGVEZWYiLCJza2luIiwiaXNTa2lubmVkTWVzaCIsImNhY2hlS2V5IiwiZGVwZW5kZW5jeSIsImxvYWRTY2VuZSIsImxvYWROb2RlIiwibG9hZE1lc2giLCJsb2FkQWNjZXNzb3IiLCJsb2FkQnVmZmVyVmlldyIsImxvYWRCdWZmZXIiLCJsb2FkTWF0ZXJpYWwiLCJsb2FkVGV4dHVyZSIsImxvYWRTa2luIiwibG9hZEFuaW1hdGlvbiIsImxvYWRDYW1lcmEiLCJkZWZzIiwiZGVmIiwiYnVmZmVySW5kZXgiLCJidWZmZXJEZWYiLCJidWZmZXJzIiwidXJpIiwicmVqZWN0IiwiYnVmZmVyVmlld0RlZiIsImJ1ZmZlclZpZXdzIiwiYnVmZmVyIiwiYWNjZXNzb3JJbmRleCIsInNwYXJzZSIsInBlbmRpbmdCdWZmZXJWaWV3cyIsIlR5cGVkQXJyYXkiLCJlbGVtZW50Qnl0ZXMiLCJCWVRFU19QRVJfRUxFTUVOVCIsIml0ZW1CeXRlcyIsImJ5dGVTdHJpZGUiLCJidWZmZXJBdHRyaWJ1dGUiLCJpYkNhY2hlS2V5IiwiaWIiLCJJbnRlcmxlYXZlZEJ1ZmZlciIsIkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiaXRlbVNpemVJbmRpY2VzIiwiU0NBTEFSIiwiVHlwZWRBcnJheUluZGljZXMiLCJieXRlT2Zmc2V0SW5kaWNlcyIsImJ5dGVPZmZzZXRWYWx1ZXMiLCJzcGFyc2VJbmRpY2VzIiwic3BhcnNlVmFsdWVzIiwic2V0QXJyYXkiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwidGV4dHVyZUluZGV4IiwiVVJMIiwid2luZG93Iiwid2Via2l0VVJMIiwidGV4dHVyZURlZiIsInRleHR1cmVzIiwidGV4dHVyZUV4dGVuc2lvbnMiLCJpbWFnZXMiLCJzb3VyY2VVUkkiLCJpc09iamVjdFVSTCIsImJsb2IiLCJCbG9iIiwibWltZVR5cGUiLCJjcmVhdGVPYmplY3RVUkwiLCJMb2FkZXIiLCJIYW5kbGVycyIsInJldm9rZU9iamVjdFVSTCIsImZsaXBZIiwiZm9ybWF0Iiwic2FtcGxlcnMiLCJzYW1wbGVyIiwibWFnRmlsdGVyIiwibWluRmlsdGVyIiwid3JhcFMiLCJ3cmFwVCIsIm1hcE5hbWUiLCJtYXBEZWYiLCJhc3NpZ25GaW5hbE1hdGVyaWFsIiwidXNlVmVydGV4VGFuZ2VudHMiLCJ0YW5nZW50IiwidXNlVmVydGV4Q29sb3JzIiwidXNlRmxhdFNoYWRpbmciLCJ1c2VTa2lubmluZyIsInVzZU1vcnBoVGFyZ2V0cyIsInVzZU1vcnBoTm9ybWFscyIsImlzUG9pbnRzIiwidXVpZCIsInBvaW50c01hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJNYXRlcmlhbCIsImlzTGluZSIsImxpbmVNYXRlcmlhbCIsIkxpbmVCYXNpY01hdGVyaWFsIiwiY2FjaGVkTWF0ZXJpYWwiLCJza2lubmluZyIsInZlcnRleFRhbmdlbnRzIiwidmVydGV4Q29sb3JzIiwiVmVydGV4Q29sb3JzIiwiZmxhdFNoYWRpbmciLCJtb3JwaFRhcmdldHMiLCJ1djIiLCJ1diIsImxvZyIsImFkZEF0dHJpYnV0ZSIsIm9uQmVmb3JlUmVuZGVyIiwibWF0ZXJpYWxJbmRleCIsIm1hdGVyaWFsRGVmIiwibWF0ZXJpYWxzIiwibWF0ZXJpYWxUeXBlIiwibWF0ZXJpYWxFeHRlbnNpb25zIiwic2dFeHRlbnNpb24iLCJrbXVFeHRlbnNpb24iLCJtZXRhbGxpY0ZhY3RvciIsInJvdWdobmVzc0ZhY3RvciIsIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsImRvdWJsZVNpZGVkIiwiRG91YmxlU2lkZSIsImFscGhhTW9kZSIsImFscGhhVGVzdCIsImFscGhhQ3V0b2ZmIiwibm9ybWFsVGV4dHVyZSIsIm9jY2x1c2lvblRleHR1cmUiLCJzdHJlbmd0aCIsImVtaXNzaXZlRmFjdG9yIiwiZW1pc3NpdmVUZXh0dXJlIiwiZW5jb2RpbmciLCJzUkdCRW5jb2RpbmciLCJhZGRQcmltaXRpdmVBdHRyaWJ1dGVzIiwiYXNzaWduQXR0cmlidXRlQWNjZXNzb3IiLCJhY2Nlc3NvciIsImdsdGZBdHRyaWJ1dGVOYW1lIiwic2V0SW5kZXgiLCJsb2FkR2VvbWV0cmllcyIsInByaW1pdGl2ZXMiLCJjcmVhdGVEcmFjb1ByaW1pdGl2ZSIsImNhY2hlZCIsInByb21pc2UiLCJnZW9tZXRyeVByb21pc2UiLCJCdWZmZXJHZW9tZXRyeSIsIm1lc2hJbmRleCIsIm9yaWdpbmFsTWF0ZXJpYWxzIiwiZ2VvbWV0cmllcyIsIlNraW5uZWRNZXNoIiwiTWVzaCIsIm5vcm1hbGl6ZVNraW5XZWlnaHRzIiwiZHJhd01vZGUiLCJUcmlhbmdsZVN0cmlwRHJhd01vZGUiLCJUcmlhbmdsZUZhbkRyYXdNb2RlIiwiTGluZVNlZ21lbnRzIiwiTGluZSIsIkxpbmVMb29wIiwiUG9pbnRzIiwiR3JvdXAiLCJjYW1lcmFJbmRleCIsImNhbWVyYURlZiIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwicmFkVG9EZWciLCJ5Zm92IiwiYXNwZWN0UmF0aW8iLCJ6bmVhciIsInpmYXIiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJ4bWFnIiwieW1hZyIsInNraW5EZWYiLCJza2luRW50cnkiLCJpbnZlcnNlQmluZE1hdHJpY2VzIiwiYW5pbWF0aW9uSW5kZXgiLCJhbmltYXRpb25EZWYiLCJwZW5kaW5nTm9kZXMiLCJwZW5kaW5nSW5wdXRBY2Nlc3NvcnMiLCJwZW5kaW5nT3V0cHV0QWNjZXNzb3JzIiwicGVuZGluZ1NhbXBsZXJzIiwicGVuZGluZ1RhcmdldHMiLCJjaGFubmVscyIsImNoYW5uZWwiLCJub2RlIiwiaWQiLCJpbnB1dCIsInBhcmFtZXRlcnMiLCJvdXRwdXQiLCJpbnB1dEFjY2Vzc29ycyIsIm91dHB1dEFjY2Vzc29ycyIsInRyYWNrcyIsImlucHV0QWNjZXNzb3IiLCJvdXRwdXRBY2Nlc3NvciIsIlR5cGVkS2V5ZnJhbWVUcmFjayIsIk51bWJlcktleWZyYW1lVHJhY2siLCJRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayIsIlZlY3RvcktleWZyYW1lVHJhY2siLCJ0YXJnZXROYW1lIiwiaW50ZXJwb2xhdGlvbiIsInRyYXZlcnNlIiwiaXNNZXNoIiwidHJhY2siLCJjcmVhdGVJbnRlcnBvbGFudCIsIkludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSIsInRpbWVzIiwiZ2V0VmFsdWVTaXplIiwiaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJBbmltYXRpb25DbGlwIiwiQm9uZSIsImluc3RhbmNlTnVtIiwiY2hpbGRyZW4iLCJvIiwibGlnaHQiLCJPYmplY3QzRCIsIlByb3BlcnR5QmluZGluZyIsInNhbml0aXplTm9kZU5hbWUiLCJhcHBseU1hdHJpeCIsInF1YXRlcm5pb24iLCJidWlsZE5vZGVIaWVyYWNoeSIsIm5vZGVJZCIsInBhcmVudE9iamVjdCIsInBlbmRpbmdKb2ludHMiLCJqb2ludE5vZGVzIiwiaXNHcm91cCIsImJvbmVzIiwiYm9uZUludmVyc2VzIiwiam9pbnROb2RlIiwibWF0IiwiYmluZCIsIlNrZWxldG9uIiwibWF0cml4V29ybGQiLCJjaGlsZCIsInNjZW5lSW5kZXgiLCJzY2VuZURlZiIsIlNjZW5l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aWEsTUFBVixDQUFrQm1QLFVBQWxCLENBQWY7QUFDQSxVQUFJNW5CLE1BQU0sR0FBRyxJQUFiO0FBRUEsVUFBSTRLLEtBQUssR0FBRyxJQUFJbFAsS0FBSyxDQUFDb3NCLEtBQVYsRUFBWjtBQUNBLFVBQUtELFFBQVEsQ0FBQ2xuQixJQUFULEtBQWtCOUUsU0FBdkIsRUFBbUMrTyxLQUFLLENBQUNqSyxJQUFOLEdBQWFrbkIsUUFBUSxDQUFDbG5CLElBQXRCO0FBRW5Dc1UsNEJBQXNCLENBQUVySyxLQUFGLEVBQVNpZCxRQUFULENBQXRCO0FBRUEsVUFBS0EsUUFBUSxDQUFDN3BCLFVBQWQsRUFBMkI0Vyw4QkFBOEIsQ0FBRTVXLFVBQUYsRUFBYzRNLEtBQWQsRUFBcUJpZCxRQUFyQixDQUE5QjtBQUUzQixVQUFJRSxPQUFPLEdBQUdGLFFBQVEsQ0FBQ2hQLEtBQVQsSUFBa0IsRUFBaEM7QUFFQSxVQUFJN1YsT0FBTyxHQUFHLEVBQWQ7O0FBRUEsV0FBTSxJQUFJbEUsQ0FBQyxHQUFHLENBQVIsRUFBVzJMLEVBQUUsR0FBR3NkLE9BQU8sQ0FBQ2hwQixNQUE5QixFQUFzQ0QsQ0FBQyxHQUFHMkwsRUFBMUMsRUFBOEMzTCxDQUFDLEVBQS9DLEVBQXFEO0FBRXBEa0UsZUFBTyxDQUFDUyxJQUFSLENBQWNxakIsaUJBQWlCLENBQUVpQixPQUFPLENBQUVqcEIsQ0FBRixDQUFULEVBQWdCOEwsS0FBaEIsRUFBdUJwTSxJQUF2QixFQUE2QndCLE1BQTdCLENBQS9CO0FBRUE7O0FBRUQsYUFBT3lDLE9BQU8sQ0FBQ2tCLEdBQVIsQ0FBYVgsT0FBYixFQUF1QmdELElBQXZCLENBQTZCLFlBQVk7QUFFL0MsZUFBTzRFLEtBQVA7QUFFQSxPQUpNLENBQVA7QUFNQSxLQTlCRDtBQWdDQSxHQXRJZ0MsRUFBakM7O0FBd0lBLFNBQU9qUCxVQUFQO0FBRUEsQ0FsbUdpQyxFQUFsQyIsImZpbGUiOiIuL2pzL0dMVEZMb2FkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAvKipcbi8vICAqIEBhdXRob3IgUmljaCBUaWJiZXR0IC8gaHR0cHM6Ly9naXRodWIuY29tL3JpY2h0clxuLy8gICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbi8vICAqIEBhdXRob3IgVG9ueSBQYXJpc2kgLyBodHRwOi8vd3d3LnRvbnlwYXJpc2kuY29tL1xuLy8gICogQGF1dGhvciBUYWthaGlybyAvIGh0dHBzOi8vZ2l0aHViLmNvbS90YWthaGlyb3hcbi8vICAqIEBhdXRob3IgRG9uIE1jQ3VyZHkgLyBodHRwczovL3d3dy5kb25tY2N1cmR5LmNvbVxuLy8gICovXG5cbmV4cG9ydCBkZWZhdWx0IFRIUkVFLkdMVEZMb2FkZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRmdW5jdGlvbiBHTFRGTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG5cblx0fVxuXG5cdEdMVEZMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IEdMVEZMb2FkZXIsXG5cblx0XHRjcm9zc09yaWdpbjogJ2Fub255bW91cycsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcmVzb3VyY2VQYXRoO1xuXG5cdFx0XHRpZiAoIHRoaXMucmVzb3VyY2VQYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGg7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJlc291cmNlUGF0aCA9IHRoaXMucGF0aDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXNvdXJjZVBhdGggPSBUSFJFRS5Mb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGVsbHMgdGhlIExvYWRpbmdNYW5hZ2VyIHRvIHRyYWNrIGFuIGV4dHJhIGl0ZW0sIHdoaWNoIHJlc29sdmVzIGFmdGVyXG5cdFx0XHQvLyB0aGUgbW9kZWwgaXMgZnVsbHkgbG9hZGVkLiBUaGlzIG1lYW5zIHRoZSBjb3VudCBvZiBpdGVtcyBsb2FkZWQgd2lsbFxuXHRcdFx0Ly8gYmUgaW5jb3JyZWN0LCBidXQgZW5zdXJlcyBtYW5hZ2VyLm9uTG9hZCgpIGRvZXMgbm90IGZpcmUgZWFybHkuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdHZhciBfb25FcnJvciA9IGZ1bmN0aW9uICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblxuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdHNjb3BlLnBhcnNlKCBkYXRhLCByZXNvdXJjZVBhdGgsIGZ1bmN0aW9uICggZ2x0ZiApIHtcblxuXHRcdFx0XHRcdFx0b25Mb2FkKCBnbHRmICk7XG5cblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0XHR9LCBfb25FcnJvciApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0X29uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIF9vbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0UmVzb3VyY2VQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RFJBQ09Mb2FkZXI6IGZ1bmN0aW9uICggZHJhY29Mb2FkZXIgKSB7XG5cblx0XHRcdHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGRhdGEsIHBhdGgsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIGNvbnRlbnQ7XG5cdFx0XHR2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHRjb250ZW50ID0gZGF0YTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgbWFnaWMgPSBUSFJFRS5Mb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YSwgMCwgNCApICk7XG5cblx0XHRcdFx0aWYgKCBtYWdpYyA9PT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgKSB7XG5cblx0XHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURiBdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oIGRhdGEgKTtcblxuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXJyb3IgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRlbnQgPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURiBdLmNvbnRlbnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnRlbnQgPSBUSFJFRS5Mb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBqc29uID0gSlNPTi5wYXJzZSggY29udGVudCApO1xuXG5cdFx0XHRpZiAoIGpzb24uYXNzZXQgPT09IHVuZGVmaW5lZCB8fCBqc29uLmFzc2V0LnZlcnNpb25bIDAgXSA8IDIgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgYXNzZXQuIGdsVEYgdmVyc2lvbnMgPj0yLjAgYXJlIHN1cHBvcnRlZC4gVXNlIExlZ2FjeUdMVEZMb2FkZXIgaW5zdGVhZC4nICkgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi5leHRlbnNpb25zVXNlZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmV4dGVuc2lvbnNVc2VkLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRcdHZhciBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFsgaSBdO1xuXHRcdFx0XHRcdHZhciBleHRlbnNpb25zUmVxdWlyZWQgPSBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCB8fCBbXTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGV4dGVuc2lvbk5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTElHSFRTX1BVTkNUVUFMOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbigganNvbiApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ6XG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oIGpzb24gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURk1hdGVyaWFsc1BiclNwZWN1bGFyR2xvc3NpbmVzc0V4dGVuc2lvbigganNvbiApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKCBqc29uLCB0aGlzLmRyYWNvTG9hZGVyICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuTVNGVF9URVhUVVJFX0REUzpcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5NU0ZUX1RFWFRVUkVfRERTIF0gPSBuZXcgR0xURlRleHR1cmVERFNFeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06XG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNIF0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oIGpzb24gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBleHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggZXh0ZW5zaW9uTmFtZSApID49IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiLicgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXJzZXIgPSBuZXcgR0xURlBhcnNlcigganNvbiwgZXh0ZW5zaW9ucywge1xuXG5cdFx0XHRcdHBhdGg6IHBhdGggfHwgdGhpcy5yZXNvdXJjZVBhdGggfHwgJycsXG5cdFx0XHRcdGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuXHRcdFx0XHRtYW5hZ2VyOiB0aGlzLm1hbmFnZXJcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwYXJzZXIucGFyc2UoIG9uTG9hZCwgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0LyogR0xURlJFR0lTVFJZICovXG5cblx0ZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuXG5cdFx0dmFyIG9iamVjdHMgPSB7fTtcblxuXHRcdHJldHVyblx0e1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3RzWyBrZXkgXTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkOiBmdW5jdGlvbiAoIGtleSwgb2JqZWN0ICkge1xuXG5cdFx0XHRcdG9iamVjdHNbIGtleSBdID0gb2JqZWN0O1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRcdGRlbGV0ZSBvYmplY3RzWyBrZXkgXTtcblxuXHRcdFx0fSxcblxuXHRcdFx0cmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0b2JqZWN0cyA9IHt9O1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKiBFWFRFTlNJT05TICoqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdHZhciBFWFRFTlNJT05TID0ge1xuXHRcdEtIUl9CSU5BUllfR0xURjogJ0tIUl9iaW5hcnlfZ2xURicsXG5cdFx0S0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046ICdLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvbicsXG5cdFx0S0hSX0xJR0hUU19QVU5DVFVBTDogJ0tIUl9saWdodHNfcHVuY3R1YWwnLFxuXHRcdEtIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1M6ICdLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcycsXG5cdFx0S0hSX01BVEVSSUFMU19VTkxJVDogJ0tIUl9tYXRlcmlhbHNfdW5saXQnLFxuXHRcdEtIUl9URVhUVVJFX1RSQU5TRk9STTogJ0tIUl90ZXh0dXJlX3RyYW5zZm9ybScsXG5cdFx0TVNGVF9URVhUVVJFX0REUzogJ01TRlRfdGV4dHVyZV9kZHMnXG5cdH07XG5cblx0LyoqXG5cdCAqIEREUyBUZXh0dXJlIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvVmVuZG9yL01TRlRfdGV4dHVyZV9kZHNcblx0ICpcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZUZXh0dXJlRERTRXh0ZW5zaW9uKCkge1xuXG5cdFx0aWYgKCAhIFRIUkVFLkREU0xvYWRlciApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogQXR0ZW1wdGluZyB0byBsb2FkIC5kZHMgdGV4dHVyZSB3aXRob3V0IGltcG9ydGluZyBUSFJFRS5ERFNMb2FkZXInICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLk1TRlRfVEVYVFVSRV9ERFM7XG5cdFx0dGhpcy5kZHNMb2FkZXIgPSBuZXcgVEhSRUUuRERTTG9hZGVyKCk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWdodHMgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IFBFTkRJTkdcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZMaWdodHNFeHRlbnNpb24oIGpzb24gKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9MSUdIVFNfUFVOQ1RVQUw7XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gKCBqc29uLmV4dGVuc2lvbnMgJiYganNvbi5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9MSUdIVFNfUFVOQ1RVQUwgXSApIHx8IHt9O1xuXHRcdHRoaXMubGlnaHREZWZzID0gZXh0ZW5zaW9uLmxpZ2h0cyB8fCBbXTtcblxuXHR9XG5cblx0R0xURkxpZ2h0c0V4dGVuc2lvbi5wcm90b3R5cGUubG9hZExpZ2h0ID0gZnVuY3Rpb24gKCBsaWdodEluZGV4ICkge1xuXG5cdFx0dmFyIGxpZ2h0RGVmID0gdGhpcy5saWdodERlZnNbIGxpZ2h0SW5kZXggXTtcblx0XHR2YXIgbGlnaHROb2RlO1xuXG5cdFx0dmFyIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXHRcdGlmICggbGlnaHREZWYuY29sb3IgIT09IHVuZGVmaW5lZCApIGNvbG9yLmZyb21BcnJheSggbGlnaHREZWYuY29sb3IgKTtcblxuXHRcdHZhciByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5yYW5nZSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBsaWdodERlZi50eXBlICkge1xuXG5cdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hZGQoIGxpZ2h0Tm9kZS50YXJnZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3BvaW50Jzpcblx0XHRcdFx0bGlnaHROb2RlID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3BvdCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BvdGxpZ2h0IHByb3BlcnRpZXMuXG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3QgPSBsaWdodERlZi5zcG90IHx8IHt9O1xuXHRcdFx0XHRsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA6IDA7XG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlIDogTWF0aC5QSSAvIDQuMDtcblx0XHRcdFx0bGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcblx0XHRcdFx0bGlnaHROb2RlLnBlbnVtYnJhID0gMS4wIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG5cdFx0XHRcdGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRcdFx0bGlnaHROb2RlLmFkZCggbGlnaHROb2RlLnRhcmdldCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlLCBcIicgKyBsaWdodERlZi50eXBlICsgJ1wiLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIFNvbWUgbGlnaHRzIChlLmcuIHNwb3QpIGRlZmF1bHQgdG8gYSBwb3NpdGlvbiBvdGhlciB0aGFuIHRoZSBvcmlnaW4uIFJlc2V0IHRoZSBwb3NpdGlvblxuXHRcdC8vIGhlcmUsIGJlY2F1c2Ugbm9kZS1sZXZlbCBwYXJzaW5nIHdpbGwgb25seSBvdmVycmlkZSBwb3NpdGlvbiBpZiBleHBsaWNpdGx5IHNwZWNpZmllZC5cblx0XHRsaWdodE5vZGUucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XG5cblx0XHRsaWdodE5vZGUuZGVjYXkgPSAyO1xuXG5cdFx0aWYgKCBsaWdodERlZi5pbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIGxpZ2h0Tm9kZS5pbnRlbnNpdHkgPSBsaWdodERlZi5pbnRlbnNpdHk7XG5cblx0XHRsaWdodE5vZGUubmFtZSA9IGxpZ2h0RGVmLm5hbWUgfHwgKCAnbGlnaHRfJyArIGxpZ2h0SW5kZXggKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIGxpZ2h0Tm9kZSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFVubGl0IE1hdGVyaWFscyBFeHRlbnNpb24gKHBlbmRpbmcpXG5cdCAqXG5cdCAqIFBSOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvcHVsbC8xMTYzXG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oIGpzb24gKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG5cblx0fVxuXG5cdEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbi5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxUeXBlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdHJldHVybiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtcblxuXHR9O1xuXG5cdEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbi5wcm90b3R5cGUuZXh0ZW5kUGFyYW1zID0gZnVuY3Rpb24gKCBtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWwsIHBhcnNlciApIHtcblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMS4wLCAxLjAsIDEuMCApO1xuXHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHR2YXIgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcztcblxuXHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MgKSB7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yICkgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fTtcblxuXHQvKiBCSU5BUlkgRVhURU5TSU9OICovXG5cblx0dmFyIEJJTkFSWV9FWFRFTlNJT05fQlVGRkVSX05BTUUgPSAnYmluYXJ5X2dsVEYnO1xuXHR2YXIgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgPSAnZ2xURic7XG5cdHZhciBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggPSAxMjtcblx0dmFyIEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMgPSB7IEpTT046IDB4NEU0RjUzNEEsIEJJTjogMHgwMDRFNDk0MiB9O1xuXG5cdGZ1bmN0aW9uIEdMVEZCaW5hcnlFeHRlbnNpb24oIGRhdGEgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURjtcblx0XHR0aGlzLmNvbnRlbnQgPSBudWxsO1xuXHRcdHRoaXMuYm9keSA9IG51bGw7XG5cblx0XHR2YXIgaGVhZGVyVmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICk7XG5cblx0XHR0aGlzLmhlYWRlciA9IHtcblx0XHRcdG1hZ2ljOiBUSFJFRS5Mb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YS5zbGljZSggMCwgNCApICkgKSxcblx0XHRcdHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKCA0LCB0cnVlICksXG5cdFx0XHRsZW5ndGg6IGhlYWRlclZpZXcuZ2V0VWludDMyKCA4LCB0cnVlIClcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLmhlYWRlci5tYWdpYyAhPT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGdsVEYtQmluYXJ5IGhlYWRlci4nICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLmhlYWRlci52ZXJzaW9uIDwgMi4wICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuIFVzZSBMZWdhY3lHTFRGTG9hZGVyIGluc3RlYWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICk7XG5cdFx0dmFyIGNodW5rSW5kZXggPSAwO1xuXG5cdFx0d2hpbGUgKCBjaHVua0luZGV4IDwgY2h1bmtWaWV3LmJ5dGVMZW5ndGggKSB7XG5cblx0XHRcdHZhciBjaHVua0xlbmd0aCA9IGNodW5rVmlldy5nZXRVaW50MzIoIGNodW5rSW5kZXgsIHRydWUgKTtcblx0XHRcdGNodW5rSW5kZXggKz0gNDtcblxuXHRcdFx0dmFyIGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoIGNodW5rSW5kZXgsIHRydWUgKTtcblx0XHRcdGNodW5rSW5kZXggKz0gNDtcblxuXHRcdFx0aWYgKCBjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuSlNPTiApIHtcblxuXHRcdFx0XHR2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXgsIGNodW5rTGVuZ3RoICk7XG5cdFx0XHRcdHRoaXMuY29udGVudCA9IFRIUkVFLkxvYWRlclV0aWxzLmRlY29kZVRleHQoIGNvbnRlbnRBcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuQklOICkge1xuXG5cdFx0XHRcdHZhciBieXRlT2Zmc2V0ID0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleDtcblx0XHRcdFx0dGhpcy5ib2R5ID0gZGF0YS5zbGljZSggYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xpZW50cyBtdXN0IGlnbm9yZSBjaHVua3Mgd2l0aCB1bmtub3duIHR5cGVzLlxuXG5cdFx0XHRjaHVua0luZGV4ICs9IGNodW5rTGVuZ3RoO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNvbnRlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogRFJBQ08gTWVzaCBDb21wcmVzc2lvbiBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3B1bGwvODc0XG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24oIGpzb24sIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0aWYgKCAhIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OO1xuXHRcdHRoaXMuanNvbiA9IGpzb247XG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuXG5cdH1cblxuXHRHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24ucHJvdG90eXBlLmRlY29kZVByaW1pdGl2ZSA9IGZ1bmN0aW9uICggcHJpbWl0aXZlLCBwYXJzZXIgKSB7XG5cblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZHJhY29Mb2FkZXIgPSB0aGlzLmRyYWNvTG9hZGVyO1xuXHRcdHZhciBidWZmZXJWaWV3SW5kZXggPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0uYnVmZmVyVmlldztcblx0XHR2YXIgZ2x0ZkF0dHJpYnV0ZU1hcCA9IHByaW1pdGl2ZS5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5hdHRyaWJ1dGVzO1xuXHRcdHZhciB0aHJlZUF0dHJpYnV0ZU1hcCA9IHt9O1xuXHRcdHZhciBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG5cdFx0dmFyIGF0dHJpYnV0ZVR5cGVNYXAgPSB7fTtcblxuXHRcdGZvciAoIHZhciBhdHRyaWJ1dGVOYW1lIGluIGdsdGZBdHRyaWJ1dGVNYXAgKSB7XG5cblx0XHRcdHZhciB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTWyBhdHRyaWJ1dGVOYW1lIF0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHR0aHJlZUF0dHJpYnV0ZU1hcFsgdGhyZWVBdHRyaWJ1dGVOYW1lIF0gPSBnbHRmQXR0cmlidXRlTWFwWyBhdHRyaWJ1dGVOYW1lIF07XG5cblx0XHR9XG5cblx0XHRmb3IgKCBhdHRyaWJ1dGVOYW1lIGluIHByaW1pdGl2ZS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBnbHRmQXR0cmlidXRlTWFwWyBhdHRyaWJ1dGVOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgYWNjZXNzb3JEZWYgPSBqc29uLmFjY2Vzc29yc1sgcHJpbWl0aXZlLmF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXSBdO1xuXHRcdFx0XHR2YXIgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSBdO1xuXG5cdFx0XHRcdGF0dHJpYnV0ZVR5cGVNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gY29tcG9uZW50VHlwZTtcblx0XHRcdFx0YXR0cmlidXRlTm9ybWFsaXplZE1hcFsgdGhyZWVBdHRyaWJ1dGVOYW1lIF0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYnVmZmVyVmlld0luZGV4ICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3ICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSApIHtcblxuXHRcdFx0XHRkcmFjb0xvYWRlci5kZWNvZGVEcmFjb0ZpbGUoIGJ1ZmZlclZpZXcsIGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xuXHRcdFx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwWyBhdHRyaWJ1dGVOYW1lIF07XG5cblx0XHRcdFx0XHRcdGlmICggbm9ybWFsaXplZCAhPT0gdW5kZWZpbmVkICkgYXR0cmlidXRlLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHR9LCB0aHJlZUF0dHJpYnV0ZU1hcCwgYXR0cmlidXRlVHlwZU1hcCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogVGV4dHVyZSBUcmFuc2Zvcm0gRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246XG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbigganNvbiApIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNO1xuXG5cdH1cblxuXHRHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbi5wcm90b3R5cGUuZXh0ZW5kVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgdHJhbnNmb3JtICkge1xuXG5cdFx0dGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcblxuXHRcdGlmICggdHJhbnNmb3JtLm9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIHRyYW5zZm9ybS5vZmZzZXQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUucm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIHRyYW5zZm9ybS5zY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm0udGV4Q29vcmQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogQ3VzdG9tIFVWIHNldHMgaW4gXCInICsgdGhpcy5uYW1lICsgJ1wiIGV4dGVuc2lvbiBub3QgeWV0IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWN1bGFyLUdsb3NzaW5lc3MgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzXG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGTWF0ZXJpYWxzUGJyU3BlY3VsYXJHbG9zc2luZXNzRXh0ZW5zaW9uKCkge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0bmFtZTogRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTLFxuXG5cdFx0XHRzcGVjdWxhckdsb3NzaW5lc3NQYXJhbXM6IFtcblx0XHRcdFx0J2NvbG9yJyxcblx0XHRcdFx0J21hcCcsXG5cdFx0XHRcdCdsaWdodE1hcCcsXG5cdFx0XHRcdCdsaWdodE1hcEludGVuc2l0eScsXG5cdFx0XHRcdCdhb01hcCcsXG5cdFx0XHRcdCdhb01hcEludGVuc2l0eScsXG5cdFx0XHRcdCdlbWlzc2l2ZScsXG5cdFx0XHRcdCdlbWlzc2l2ZUludGVuc2l0eScsXG5cdFx0XHRcdCdlbWlzc2l2ZU1hcCcsXG5cdFx0XHRcdCdidW1wTWFwJyxcblx0XHRcdFx0J2J1bXBTY2FsZScsXG5cdFx0XHRcdCdub3JtYWxNYXAnLFxuXHRcdFx0XHQnZGlzcGxhY2VtZW50TWFwJyxcblx0XHRcdFx0J2Rpc3BsYWNlbWVudFNjYWxlJyxcblx0XHRcdFx0J2Rpc3BsYWNlbWVudEJpYXMnLFxuXHRcdFx0XHQnc3BlY3VsYXJNYXAnLFxuXHRcdFx0XHQnc3BlY3VsYXInLFxuXHRcdFx0XHQnZ2xvc3NpbmVzc01hcCcsXG5cdFx0XHRcdCdnbG9zc2luZXNzJyxcblx0XHRcdFx0J2FscGhhTWFwJyxcblx0XHRcdFx0J2Vudk1hcCcsXG5cdFx0XHRcdCdlbnZNYXBJbnRlbnNpdHknLFxuXHRcdFx0XHQncmVmcmFjdGlvblJhdGlvJyxcblx0XHRcdF0sXG5cblx0XHRcdGdldE1hdGVyaWFsVHlwZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZXh0ZW5kUGFyYW1zOiBmdW5jdGlvbiAoIHBhcmFtcywgbWF0ZXJpYWwsIHBhcnNlciApIHtcblxuXHRcdFx0XHR2YXIgcGJyU3BlY3VsYXJHbG9zc2luZXNzID0gbWF0ZXJpYWwuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgJ3N0YW5kYXJkJyBdO1xuXG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdFx0XHRcdHZhciBzcGVjdWxhck1hcFBhcnNGcmFnbWVudENodW5rID0gW1xuXHRcdFx0XHRcdCcjaWZkZWYgVVNFX1NQRUNVTEFSTUFQJyxcblx0XHRcdFx0XHQnXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDsnLFxuXHRcdFx0XHRcdCcjZW5kaWYnXG5cdFx0XHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdFx0XHR2YXIgZ2xvc3NpbmVzc01hcFBhcnNGcmFnbWVudENodW5rID0gW1xuXHRcdFx0XHRcdCcjaWZkZWYgVVNFX0dMT1NTSU5FU1NNQVAnLFxuXHRcdFx0XHRcdCdcdHVuaWZvcm0gc2FtcGxlcjJEIGdsb3NzaW5lc3NNYXA7Jyxcblx0XHRcdFx0XHQnI2VuZGlmJ1xuXHRcdFx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHRcdFx0dmFyIHNwZWN1bGFyTWFwRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdFx0XHQndmVjMyBzcGVjdWxhckZhY3RvciA9IHNwZWN1bGFyOycsXG5cdFx0XHRcdFx0JyNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAnLFxuXHRcdFx0XHRcdCdcdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApOycsXG5cdFx0XHRcdFx0J1x0dGV4ZWxTcGVjdWxhciA9IHNSR0JUb0xpbmVhciggdGV4ZWxTcGVjdWxhciApOycsXG5cdFx0XHRcdFx0J1x0Ly8gcmVhZHMgY2hhbm5lbCBSR0IsIGNvbXBhdGlibGUgd2l0aCBhIGdsVEYgU3BlY3VsYXItR2xvc3NpbmVzcyAoUkdCQSkgdGV4dHVyZScsXG5cdFx0XHRcdFx0J1x0c3BlY3VsYXJGYWN0b3IgKj0gdGV4ZWxTcGVjdWxhci5yZ2I7Jyxcblx0XHRcdFx0XHQnI2VuZGlmJ1xuXHRcdFx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHRcdFx0dmFyIGdsb3NzaW5lc3NNYXBGcmFnbWVudENodW5rID0gW1xuXHRcdFx0XHRcdCdmbG9hdCBnbG9zc2luZXNzRmFjdG9yID0gZ2xvc3NpbmVzczsnLFxuXHRcdFx0XHRcdCcjaWZkZWYgVVNFX0dMT1NTSU5FU1NNQVAnLFxuXHRcdFx0XHRcdCdcdHZlYzQgdGV4ZWxHbG9zc2luZXNzID0gdGV4dHVyZTJEKCBnbG9zc2luZXNzTWFwLCB2VXYgKTsnLFxuXHRcdFx0XHRcdCdcdC8vIHJlYWRzIGNoYW5uZWwgQSwgY29tcGF0aWJsZSB3aXRoIGEgZ2xURiBTcGVjdWxhci1HbG9zc2luZXNzIChSR0JBKSB0ZXh0dXJlJyxcblx0XHRcdFx0XHQnXHRnbG9zc2luZXNzRmFjdG9yICo9IHRleGVsR2xvc3NpbmVzcy5hOycsXG5cdFx0XHRcdFx0JyNlbmRpZidcblx0XHRcdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0XHRcdHZhciBsaWdodFBoeXNpY2FsRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdFx0XHQnUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDsnLFxuXHRcdFx0XHRcdCdtYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiOycsXG5cdFx0XHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIDEuMCAtIGdsb3NzaW5lc3NGYWN0b3IsIDAuMDQsIDEuMCApOycsXG5cdFx0XHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhckZhY3Rvci5yZ2I7Jyxcblx0XHRcdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0XHRcdHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXHRcdFx0XHRcdC5yZXBsYWNlKCAndW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7JywgJ3VuaWZvcm0gdmVjMyBzcGVjdWxhcjsnIClcblx0XHRcdFx0XHQucmVwbGFjZSggJ3VuaWZvcm0gZmxvYXQgbWV0YWxuZXNzOycsICd1bmlmb3JtIGZsb2F0IGdsb3NzaW5lc3M7JyApXG5cdFx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ+Jywgc3BlY3VsYXJNYXBQYXJzRnJhZ21lbnRDaHVuayApXG5cdFx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+JywgZ2xvc3NpbmVzc01hcFBhcnNGcmFnbWVudENodW5rIClcblx0XHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+Jywgc3BlY3VsYXJNYXBGcmFnbWVudENodW5rIClcblx0XHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+JywgZ2xvc3NpbmVzc01hcEZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD4nLCBsaWdodFBoeXNpY2FsRnJhZ21lbnRDaHVuayApO1xuXG5cdFx0XHRcdGRlbGV0ZSB1bmlmb3Jtcy5yb3VnaG5lc3M7XG5cdFx0XHRcdGRlbGV0ZSB1bmlmb3Jtcy5tZXRhbG5lc3M7XG5cdFx0XHRcdGRlbGV0ZSB1bmlmb3Jtcy5yb3VnaG5lc3NNYXA7XG5cdFx0XHRcdGRlbGV0ZSB1bmlmb3Jtcy5tZXRhbG5lc3NNYXA7XG5cblx0XHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIgPSB7IHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoKS5zZXRIZXgoIDB4MTExMTExICkgfTtcblx0XHRcdFx0dW5pZm9ybXMuZ2xvc3NpbmVzcyA9IHsgdmFsdWU6IDAuNSB9O1xuXHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhck1hcCA9IHsgdmFsdWU6IG51bGwgfTtcblx0XHRcdFx0dW5pZm9ybXMuZ2xvc3NpbmVzc01hcCA9IHsgdmFsdWU6IG51bGwgfTtcblxuXHRcdFx0XHRwYXJhbXMudmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlcjtcblx0XHRcdFx0cGFyYW1zLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XG5cdFx0XHRcdHBhcmFtcy51bmlmb3JtcyA9IHVuaWZvcm1zO1xuXHRcdFx0XHRwYXJhbXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcblxuXHRcdFx0XHRwYXJhbXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblx0XHRcdFx0cGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlRmFjdG9yICkgKSB7XG5cblx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZUZhY3RvcjtcblxuXHRcdFx0XHRcdHBhcmFtcy5jb2xvci5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0cGFyYW1zLm9wYWNpdHkgPSBhcnJheVsgMyBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggcGFyYW1zLCAnbWFwJywgcGJyU3BlY3VsYXJHbG9zc2luZXNzLmRpZmZ1c2VUZXh0dXJlICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFyYW1zLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAwLjAsIDAuMCwgMC4wICk7XG5cdFx0XHRcdHBhcmFtcy5nbG9zc2luZXNzID0gcGJyU3BlY3VsYXJHbG9zc2luZXNzLmdsb3NzaW5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IHBiclNwZWN1bGFyR2xvc3NpbmVzcy5nbG9zc2luZXNzRmFjdG9yIDogMS4wO1xuXHRcdFx0XHRwYXJhbXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckZhY3RvciApICkge1xuXG5cdFx0XHRcdFx0cGFyYW1zLnNwZWN1bGFyLmZyb21BcnJheSggcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyRmFjdG9yICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciBzcGVjR2xvc3NNYXBEZWYgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3Muc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZTtcblx0XHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBwYXJhbXMsICdnbG9zc2luZXNzTWFwJywgc3BlY0dsb3NzTWFwRGVmICkgKTtcblx0XHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBwYXJhbXMsICdzcGVjdWxhck1hcCcsIHNwZWNHbG9zc01hcERlZiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRjcmVhdGVNYXRlcmlhbDogZnVuY3Rpb24gKCBwYXJhbXMgKSB7XG5cblx0XHRcdFx0Ly8gc2V0dXAgbWF0ZXJpYWwgcHJvcGVydGllcyBiYXNlZCBvbiBNZXNoU3RhbmRhcmRNYXRlcmlhbCBmb3IgU3BlY3VsYXItR2xvc3NpbmVzc1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuXHRcdFx0XHRcdGRlZmluZXM6IHBhcmFtcy5kZWZpbmVzLFxuXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogcGFyYW1zLnZlcnRleFNoYWRlcixcblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogcGFyYW1zLmZyYWdtZW50U2hhZGVyLFxuXHRcdFx0XHRcdHVuaWZvcm1zOiBwYXJhbXMudW5pZm9ybXMsXG5cdFx0XHRcdFx0Zm9nOiB0cnVlLFxuXHRcdFx0XHRcdGxpZ2h0czogdHJ1ZSxcblx0XHRcdFx0XHRvcGFjaXR5OiBwYXJhbXMub3BhY2l0eSxcblx0XHRcdFx0XHR0cmFuc3BhcmVudDogcGFyYW1zLnRyYW5zcGFyZW50XG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRtYXRlcmlhbC5pc0dMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCA9IHRydWU7XG5cblx0XHRcdFx0bWF0ZXJpYWwuY29sb3IgPSBwYXJhbXMuY29sb3I7XG5cblx0XHRcdFx0bWF0ZXJpYWwubWFwID0gcGFyYW1zLm1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHBhcmFtcy5tYXA7XG5cblx0XHRcdFx0bWF0ZXJpYWwubGlnaHRNYXAgPSBudWxsO1xuXHRcdFx0XHRtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdFx0XHRtYXRlcmlhbC5hb01hcCA9IHBhcmFtcy5hb01hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHBhcmFtcy5hb01hcDtcblx0XHRcdFx0bWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHRcdFx0bWF0ZXJpYWwuZW1pc3NpdmUgPSBwYXJhbXMuZW1pc3NpdmU7XG5cdFx0XHRcdG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0XHRtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IHBhcmFtcy5lbWlzc2l2ZU1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHBhcmFtcy5lbWlzc2l2ZU1hcDtcblxuXHRcdFx0XHRtYXRlcmlhbC5idW1wTWFwID0gcGFyYW1zLmJ1bXBNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBwYXJhbXMuYnVtcE1hcDtcblx0XHRcdFx0bWF0ZXJpYWwuYnVtcFNjYWxlID0gMTtcblxuXHRcdFx0XHRtYXRlcmlhbC5ub3JtYWxNYXAgPSBwYXJhbXMubm9ybWFsTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogcGFyYW1zLm5vcm1hbE1hcDtcblx0XHRcdFx0aWYgKCBwYXJhbXMubm9ybWFsU2NhbGUgKSBtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IHBhcmFtcy5ub3JtYWxTY2FsZTtcblxuXHRcdFx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdFx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0XHRcdG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gcGFyYW1zLnNwZWN1bGFyTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogcGFyYW1zLnNwZWN1bGFyTWFwO1xuXHRcdFx0XHRtYXRlcmlhbC5zcGVjdWxhciA9IHBhcmFtcy5zcGVjdWxhcjtcblxuXHRcdFx0XHRtYXRlcmlhbC5nbG9zc2luZXNzTWFwID0gcGFyYW1zLmdsb3NzaW5lc3NNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBwYXJhbXMuZ2xvc3NpbmVzc01hcDtcblx0XHRcdFx0bWF0ZXJpYWwuZ2xvc3NpbmVzcyA9IHBhcmFtcy5nbG9zc2luZXNzO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdFx0XHRtYXRlcmlhbC5lbnZNYXAgPSBwYXJhbXMuZW52TWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogcGFyYW1zLmVudk1hcDtcblx0XHRcdFx0bWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHRcdFx0bWF0ZXJpYWwuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyA9IHRydWU7XG5cblx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENsb25lcyBhIEdMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCBpbnN0YW5jZS4gVGhlIFNoYWRlck1hdGVyaWFsLmNvcHkoKSBtZXRob2QgY2FuXG5cdFx0XHQgKiBjb3B5IG9ubHkgcHJvcGVydGllcyBpdCBrbm93cyBhYm91dCBvciBpbmhlcml0cywgYW5kIG1pc3NlcyBtYW55IHByb3BlcnRpZXMgdGhhdCB3b3VsZFxuXHRcdFx0ICogbm9ybWFsbHkgYmUgZGVmaW5lZCBieSBNZXNoU3RhbmRhcmRNYXRlcmlhbC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGlzIG1ldGhvZCBhbGxvd3MgR0xURlNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFscyB0byBiZSBjbG9uZWQgaW4gdGhlIHByb2Nlc3Mgb2Zcblx0XHRcdCAqIGxvYWRpbmcgYSBnbFRGIG1vZGVsLCBidXQgY2xvbmluZyBsYXRlciAoZS5nLiBieSB0aGUgdXNlcikgd291bGQgcmVxdWlyZSB0aGVzZSBjaGFuZ2VzXG5cdFx0XHQgKiBBTkQgYWxzbyB1cGRhdGluZyBgLm9uQmVmb3JlUmVuZGVyYCBvbiB0aGUgcGFyZW50IG1lc2guXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtICB7VEhSRUUuU2hhZGVyTWF0ZXJpYWx9IHNvdXJjZVxuXHRcdFx0ICogQHJldHVybiB7VEhSRUUuU2hhZGVyTWF0ZXJpYWx9XG5cdFx0XHQgKi9cblx0XHRcdGNsb25lTWF0ZXJpYWw6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHRcdHZhciB0YXJnZXQgPSBzb3VyY2UuY2xvbmUoKTtcblxuXHRcdFx0XHR0YXJnZXQuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBwYXJhbXMgPSB0aGlzLnNwZWN1bGFyR2xvc3NpbmVzc1BhcmFtcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcGFyYW1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0WyBwYXJhbXNbIGkgXSBdID0gc291cmNlWyBwYXJhbXNbIGkgXSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBIZXJlJ3MgYmFzZWQgb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCkgYW5kIHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCkgaW4gV2ViR0xSZW5kZXJlci5cblx0XHRcdHJlZnJlc2hVbmlmb3JtczogZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApIHtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzR0xURlNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3Jtcztcblx0XHRcdFx0dmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xuXG5cdFx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKS5tdWx0aXBseVNjYWxhciggbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cblx0XHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcblx0XHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0XHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuXHRcdFx0XHQvLyAxLiBjb2xvciBtYXBcblx0XHRcdFx0Ly8gMi4gc3BlY3VsYXIgbWFwXG5cdFx0XHRcdC8vIDMuIG5vcm1hbCBtYXBcblx0XHRcdFx0Ly8gNC4gYnVtcCBtYXBcblx0XHRcdFx0Ly8gNS4gYWxwaGEgbWFwXG5cdFx0XHRcdC8vIDYuIGVtaXNzaXZlIG1hcFxuXG5cdFx0XHRcdHZhciB1dlNjYWxlTWFwO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcblxuXHRcdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cblx0XHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuXHRcdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuXHRcdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmdsb3NzaW5lc3NNYXAgKSB7XG5cblx0XHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZ2xvc3NpbmVzc01hcDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcblxuXHRcdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuXHRcdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdGlmICggdXZTY2FsZU1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0XHR1dlNjYWxlTWFwID0gdXZTY2FsZU1hcC50ZXh0dXJlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdHV2U2NhbGVNYXAudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KCB1dlNjYWxlTWFwLm1hdHJpeCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmVudk1hcCApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcblx0XHRcdFx0XHR1bmlmb3Jtcy5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHk7XG5cblx0XHRcdFx0XHQvLyBkb24ndCBmbGlwIEN1YmVUZXh0dXJlIGVudk1hcHMsIGZsaXAgZXZlcnl0aGluZyBlbHNlOlxuXHRcdFx0XHRcdC8vICBXZWJHTFJlbmRlclRhcmdldEN1YmUgd2lsbCBiZSBmbGlwcGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRcdC8vICBXZWJHTFJlbmRlclRhcmdldEN1YmUudGV4dHVyZSB3aWxsIGJlIGZsaXBwZWQgYmVjYXVzZSBpdCdzIGEgVGV4dHVyZSBhbmQgTk9UIGEgQ3ViZVRleHR1cmVcblx0XHRcdFx0XHQvLyB0aGlzIGNoZWNrIG11c3QgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSwgb3IgcmVtb3ZlZCBlbnRpcmVseSwgaWYgV2ViR0xSZW5kZXJUYXJnZXRDdWJlIHVzZXMgYSBDdWJlVGV4dHVyZSBpbiB0aGUgZnV0dXJlXG5cdFx0XHRcdFx0dW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcC5pc0N1YmVUZXh0dXJlID8gLSAxIDogMTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5tYXhNaXBMZXZlbC52YWx1ZSA9IHJlbmRlcmVyLnByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbC5lbnZNYXAgKS5fX21heE1pcExldmVsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZS5jb3B5KCBtYXRlcmlhbC5zcGVjdWxhciApO1xuXHRcdFx0XHR1bmlmb3Jtcy5nbG9zc2luZXNzLnZhbHVlID0gbWF0ZXJpYWwuZ2xvc3NpbmVzcztcblxuXHRcdFx0XHR1bmlmb3Jtcy5nbG9zc2luZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwuZ2xvc3NpbmVzc01hcDtcblxuXHRcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRcdFx0aWYgKCB1bmlmb3Jtcy5nbG9zc2luZXNzTWFwLnZhbHVlICE9PSBudWxsICYmIGRlZmluZXMuVVNFX0dMT1NTSU5FU1NNQVAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGRlZmluZXMuVVNFX0dMT1NTSU5FU1NNQVAgPSAnJztcblx0XHRcdFx0XHQvLyBzZXQgVVNFX1JPVUdITkVTU01BUCB0byBlbmFibGUgdlV2XG5cdFx0XHRcdFx0ZGVmaW5lcy5VU0VfUk9VR0hORVNTTUFQID0gJyc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdW5pZm9ybXMuZ2xvc3NpbmVzc01hcC52YWx1ZSA9PT0gbnVsbCAmJiBkZWZpbmVzLlVTRV9HTE9TU0lORVNTTUFQICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRkZWxldGUgZGVmaW5lcy5VU0VfR0xPU1NJTkVTU01BUDtcblx0XHRcdFx0XHRkZWxldGUgZGVmaW5lcy5VU0VfUk9VR0hORVNTTUFQO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKiogSU5URVJQT0xBVElPTiAqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvLyBTcGxpbmUgSW50ZXJwb2xhdGlvblxuXHQvLyBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FwcGVuZGl4LWMtc3BsaW5lLWludGVycG9sYXRpb25cblx0ZnVuY3Rpb24gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cblx0fVxuXG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZSApO1xuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudDtcblxuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyA9IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHQvLyBDb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXIuIFNlZSBkZXNjcmlwdGlvbiBvZiBnbFRGXG5cdFx0Ly8gQ1VCSUNTUExJTkUgdmFsdWVzIGxheW91dCBpbiBpbnRlcnBvbGF0ZV8oKSBmdW5jdGlvbiBiZWxvdy5cblxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0dmFsdWVTaXplID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQgPSBpbmRleCAqIHZhbHVlU2l6ZSAqIDMgKyB2YWx1ZVNpemU7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHZhbHVlU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0cmVzdWx0WyBpIF0gPSB2YWx1ZXNbIG9mZnNldCArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fTtcblxuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuYmVmb3JlU3RhcnRfID0gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV87XG5cblx0R0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmFmdGVyRW5kXyA9IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfO1xuXG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5pbnRlcnBvbGF0ZV8gPSBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzO1xuXHRcdHZhciBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcblxuXHRcdHZhciBzdHJpZGUyID0gc3RyaWRlICogMjtcblx0XHR2YXIgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG5cblx0XHR2YXIgdGQgPSB0MSAtIHQwO1xuXG5cdFx0dmFyIHAgPSAoIHQgLSB0MCApIC8gdGQ7XG5cdFx0dmFyIHBwID0gcCAqIHA7XG5cdFx0dmFyIHBwcCA9IHBwICogcDtcblxuXHRcdHZhciBvZmZzZXQxID0gaTEgKiBzdHJpZGUzO1xuXHRcdHZhciBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZTM7XG5cblx0XHR2YXIgczIgPSAtIDIgKiBwcHAgKyAzICogcHA7XG5cdFx0dmFyIHMzID0gcHBwIC0gcHA7XG5cdFx0dmFyIHMwID0gMSAtIHMyO1xuXHRcdHZhciBzMSA9IHMzIC0gcHAgKyBwO1xuXG5cdFx0Ly8gTGF5b3V0IG9mIGtleWZyYW1lIG91dHB1dCB2YWx1ZXMgZm9yIENVQklDU1BMSU5FIGFuaW1hdGlvbnM6XG5cdFx0Ly8gICBbIGluVGFuZ2VudF8xLCBzcGxpbmVWZXJ0ZXhfMSwgb3V0VGFuZ2VudF8xLCBpblRhbmdlbnRfMiwgc3BsaW5lVmVydGV4XzIsIC4uLiBdXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7IGkgKysgKSB7XG5cblx0XHRcdHZhciBwMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUgXTsgLy8gc3BsaW5lVmVydGV4X2tcblx0XHRcdHZhciBtMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUyIF0gKiB0ZDsgLy8gb3V0VGFuZ2VudF9rICogKHRfaysxIC0gdF9rKVxuXHRcdFx0dmFyIHAxID0gdmFsdWVzWyBvZmZzZXQxICsgaSArIHN0cmlkZSBdOyAvLyBzcGxpbmVWZXJ0ZXhfaysxXG5cdFx0XHR2YXIgbTEgPSB2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB0ZDsgLy8gaW5UYW5nZW50X2srMSAqICh0X2srMSAtIHRfaylcblxuXHRcdFx0cmVzdWx0WyBpIF0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqIElOVEVSTkFMUyAqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0LyogQ09OU1RBTlRTICovXG5cblx0dmFyIFdFQkdMX0NPTlNUQU5UUyA9IHtcblx0XHRGTE9BVDogNTEyNixcblx0XHQvL0ZMT0FUX01BVDI6IDM1Njc0LFxuXHRcdEZMT0FUX01BVDM6IDM1Njc1LFxuXHRcdEZMT0FUX01BVDQ6IDM1Njc2LFxuXHRcdEZMT0FUX1ZFQzI6IDM1NjY0LFxuXHRcdEZMT0FUX1ZFQzM6IDM1NjY1LFxuXHRcdEZMT0FUX1ZFQzQ6IDM1NjY2LFxuXHRcdExJTkVBUjogOTcyOSxcblx0XHRSRVBFQVQ6IDEwNDk3LFxuXHRcdFNBTVBMRVJfMkQ6IDM1Njc4LFxuXHRcdFBPSU5UUzogMCxcblx0XHRMSU5FUzogMSxcblx0XHRMSU5FX0xPT1A6IDIsXG5cdFx0TElORV9TVFJJUDogMyxcblx0XHRUUklBTkdMRVM6IDQsXG5cdFx0VFJJQU5HTEVfU1RSSVA6IDUsXG5cdFx0VFJJQU5HTEVfRkFOOiA2LFxuXHRcdFVOU0lHTkVEX0JZVEU6IDUxMjEsXG5cdFx0VU5TSUdORURfU0hPUlQ6IDUxMjNcblx0fTtcblxuXHR2YXIgV0VCR0xfVFlQRSA9IHtcblx0XHQ1MTI2OiBOdW1iZXIsXG5cdFx0Ly8zNTY3NDogVEhSRUUuTWF0cml4Mixcblx0XHQzNTY3NTogVEhSRUUuTWF0cml4Myxcblx0XHQzNTY3NjogVEhSRUUuTWF0cml4NCxcblx0XHQzNTY2NDogVEhSRUUuVmVjdG9yMixcblx0XHQzNTY2NTogVEhSRUUuVmVjdG9yMyxcblx0XHQzNTY2NjogVEhSRUUuVmVjdG9yNCxcblx0XHQzNTY3ODogVEhSRUUuVGV4dHVyZVxuXHR9O1xuXG5cdHZhciBXRUJHTF9DT01QT05FTlRfVFlQRVMgPSB7XG5cdFx0NTEyMDogSW50OEFycmF5LFxuXHRcdDUxMjE6IFVpbnQ4QXJyYXksXG5cdFx0NTEyMjogSW50MTZBcnJheSxcblx0XHQ1MTIzOiBVaW50MTZBcnJheSxcblx0XHQ1MTI1OiBVaW50MzJBcnJheSxcblx0XHQ1MTI2OiBGbG9hdDMyQXJyYXlcblx0fTtcblxuXHR2YXIgV0VCR0xfRklMVEVSUyA9IHtcblx0XHQ5NzI4OiBUSFJFRS5OZWFyZXN0RmlsdGVyLFxuXHRcdDk3Mjk6IFRIUkVFLkxpbmVhckZpbHRlcixcblx0XHQ5OTg0OiBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcixcblx0XHQ5OTg1OiBUSFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyLFxuXHRcdDk5ODY6IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIsXG5cdFx0OTk4NzogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyXG5cdH07XG5cblx0dmFyIFdFQkdMX1dSQVBQSU5HUyA9IHtcblx0XHQzMzA3MTogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyxcblx0XHQzMzY0ODogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcblx0XHQxMDQ5NzogVEhSRUUuUmVwZWF0V3JhcHBpbmdcblx0fTtcblxuXHR2YXIgV0VCR0xfU0lERVMgPSB7XG5cdFx0MTAyODogVEhSRUUuQmFja1NpZGUsIC8vIEN1bGxpbmcgZnJvbnRcblx0XHQxMDI5OiBUSFJFRS5Gcm9udFNpZGUgLy8gQ3VsbGluZyBiYWNrXG5cdFx0Ly8xMDMyOiBUSFJFRS5Ob1NpZGUgICAvLyBDdWxsaW5nIGZyb250IGFuZCBiYWNrLCB3aGF0IHRvIGRvP1xuXHR9O1xuXG5cdHZhciBXRUJHTF9ERVBUSF9GVU5DUyA9IHtcblx0XHQ1MTI6IFRIUkVFLk5ldmVyRGVwdGgsXG5cdFx0NTEzOiBUSFJFRS5MZXNzRGVwdGgsXG5cdFx0NTE0OiBUSFJFRS5FcXVhbERlcHRoLFxuXHRcdDUxNTogVEhSRUUuTGVzc0VxdWFsRGVwdGgsXG5cdFx0NTE2OiBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aCxcblx0XHQ1MTc6IFRIUkVFLk5vdEVxdWFsRGVwdGgsXG5cdFx0NTE4OiBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aCxcblx0XHQ1MTk6IFRIUkVFLkFsd2F5c0RlcHRoXG5cdH07XG5cblx0dmFyIFdFQkdMX0JMRU5EX0VRVUFUSU9OUyA9IHtcblx0XHQzMjc3NDogVEhSRUUuQWRkRXF1YXRpb24sXG5cdFx0MzI3Nzg6IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24sXG5cdFx0MzI3Nzk6IFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uXG5cdH07XG5cblx0dmFyIFdFQkdMX0JMRU5EX0ZVTkNTID0ge1xuXHRcdDA6IFRIUkVFLlplcm9GYWN0b3IsXG5cdFx0MTogVEhSRUUuT25lRmFjdG9yLFxuXHRcdDc2ODogVEhSRUUuU3JjQ29sb3JGYWN0b3IsXG5cdFx0NzY5OiBUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yLFxuXHRcdDc3MDogVEhSRUUuU3JjQWxwaGFGYWN0b3IsXG5cdFx0NzcxOiBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yLFxuXHRcdDc3MjogVEhSRUUuRHN0QWxwaGFGYWN0b3IsXG5cdFx0NzczOiBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yLFxuXHRcdDc3NDogVEhSRUUuRHN0Q29sb3JGYWN0b3IsXG5cdFx0Nzc1OiBUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yLFxuXHRcdDc3NjogVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvclxuXHRcdC8vIFRoZSBmb2xsb3dpbmdzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IFRocmVlLmpzIHlldFxuXHRcdC8vMzI3Njk6IENPTlNUQU5UX0NPTE9SLFxuXHRcdC8vMzI3NzA6IE9ORV9NSU5VU19DT05TVEFOVF9DT0xPUixcblx0XHQvLzMyNzcxOiBDT05TVEFOVF9BTFBIQSxcblx0XHQvLzMyNzcyOiBPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1Jcblx0fTtcblxuXHR2YXIgV0VCR0xfVFlQRV9TSVpFUyA9IHtcblx0XHQnU0NBTEFSJzogMSxcblx0XHQnVkVDMic6IDIsXG5cdFx0J1ZFQzMnOiAzLFxuXHRcdCdWRUM0JzogNCxcblx0XHQnTUFUMic6IDQsXG5cdFx0J01BVDMnOiA5LFxuXHRcdCdNQVQ0JzogMTZcblx0fTtcblxuXHR2YXIgQVRUUklCVVRFUyA9IHtcblx0XHRQT1NJVElPTjogJ3Bvc2l0aW9uJyxcblx0XHROT1JNQUw6ICdub3JtYWwnLFxuXHRcdFRBTkdFTlQ6ICd0YW5nZW50Jyxcblx0XHRURVhDT09SRF8wOiAndXYnLFxuXHRcdFRFWENPT1JEXzE6ICd1djInLFxuXHRcdENPTE9SXzA6ICdjb2xvcicsXG5cdFx0V0VJR0hUU18wOiAnc2tpbldlaWdodCcsXG5cdFx0Sk9JTlRTXzA6ICdza2luSW5kZXgnLFxuXHR9O1xuXG5cdHZhciBQQVRIX1BST1BFUlRJRVMgPSB7XG5cdFx0c2NhbGU6ICdzY2FsZScsXG5cdFx0dHJhbnNsYXRpb246ICdwb3NpdGlvbicsXG5cdFx0cm90YXRpb246ICdxdWF0ZXJuaW9uJyxcblx0XHR3ZWlnaHRzOiAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJ1xuXHR9O1xuXG5cdHZhciBJTlRFUlBPTEFUSU9OID0ge1xuXHRcdENVQklDU1BMSU5FOiB1bmRlZmluZWQsIC8vIFdlIHVzZSBhIGN1c3RvbSBpbnRlcnBvbGFudCAoR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhdGlvbikgZm9yIENVQklDU1BMSU5FIHRyYWNrcy4gRWFjaFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuXHRcdExJTkVBUjogVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIsXG5cdFx0U1RFUDogVEhSRUUuSW50ZXJwb2xhdGVEaXNjcmV0ZVxuXHR9O1xuXG5cdHZhciBTVEFURVNfRU5BQkxFUyA9IHtcblx0XHQyODg0OiAnQ1VMTF9GQUNFJyxcblx0XHQyOTI5OiAnREVQVEhfVEVTVCcsXG5cdFx0MzA0MjogJ0JMRU5EJyxcblx0XHQzMDg5OiAnU0NJU1NPUl9URVNUJyxcblx0XHQzMjgyMzogJ1BPTFlHT05fT0ZGU0VUX0ZJTEwnLFxuXHRcdDMyOTI2OiAnU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFJ1xuXHR9O1xuXG5cdHZhciBBTFBIQV9NT0RFUyA9IHtcblx0XHRPUEFRVUU6ICdPUEFRVUUnLFxuXHRcdE1BU0s6ICdNQVNLJyxcblx0XHRCTEVORDogJ0JMRU5EJ1xuXHR9O1xuXG5cdHZhciBNSU1FX1RZUEVfRk9STUFUUyA9IHtcblx0XHQnaW1hZ2UvcG5nJzogVEhSRUUuUkdCQUZvcm1hdCxcblx0XHQnaW1hZ2UvanBlZyc6IFRIUkVFLlJHQkZvcm1hdFxuXHR9O1xuXG5cdC8qIFVUSUxJVFkgRlVOQ1RJT05TICovXG5cblx0ZnVuY3Rpb24gcmVzb2x2ZVVSTCggdXJsLCBwYXRoICkge1xuXG5cdFx0Ly8gSW52YWxpZCBVUkxcblx0XHRpZiAoIHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybCA9PT0gJycgKSByZXR1cm4gJyc7XG5cblx0XHQvLyBBYnNvbHV0ZSBVUkwgaHR0cDovLyxodHRwczovLywvL1xuXHRcdGlmICggL14oaHR0cHM/Oik/XFwvXFwvL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gRGF0YSBVUklcblx0XHRpZiAoIC9eZGF0YTouKiwuKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHQvLyBCbG9iIFVSTFxuXHRcdGlmICggL15ibG9iOi4qJC9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdC8vIFJlbGF0aXZlIFVSTFxuXHRcdHJldHVybiBwYXRoICsgdXJsO1xuXG5cdH1cblxuXHR2YXIgZGVmYXVsdE1hdGVyaWFsO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2RlZmF1bHQtbWF0ZXJpYWxcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRNYXRlcmlhbCgpIHtcblxuXHRcdGRlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRNYXRlcmlhbCB8fCBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoIHtcblx0XHRcdGNvbG9yOiAweEZGRkZGRixcblx0XHRcdGVtaXNzaXZlOiAweDAwMDAwMCxcblx0XHRcdG1ldGFsbmVzczogMSxcblx0XHRcdHJvdWdobmVzczogMSxcblx0XHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcblx0XHRcdGRlcHRoVGVzdDogdHJ1ZSxcblx0XHRcdHNpZGU6IFRIUkVFLkZyb250U2lkZVxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBkZWZhdWx0TWF0ZXJpYWw7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSgga25vd25FeHRlbnNpb25zLCBvYmplY3QsIG9iamVjdERlZiApIHtcblxuXHRcdC8vIEFkZCB1bmtub3duIGdsVEYgZXh0ZW5zaW9ucyB0byBhbiBvYmplY3QncyB1c2VyRGF0YS5cblxuXHRcdGZvciAoIHZhciBuYW1lIGluIG9iamVjdERlZi5leHRlbnNpb25zICkge1xuXG5cdFx0XHRpZiAoIGtub3duRXh0ZW5zaW9uc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuXHRcdFx0XHRvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnNbIG5hbWUgXSA9IG9iamVjdERlZi5leHRlbnNpb25zWyBuYW1lIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VEhSRUUuT2JqZWN0M0R8VEhSRUUuTWF0ZXJpYWx8VEhSRUUuQnVmZmVyR2VvbWV0cnl9IG9iamVjdFxuXHQgKiBAcGFyYW0ge0dMVEYuZGVmaW5pdGlvbn0gZ2x0ZkRlZlxuXHQgKi9cblx0ZnVuY3Rpb24gYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggb2JqZWN0LCBnbHRmRGVmICkge1xuXG5cdFx0aWYgKCBnbHRmRGVmLmV4dHJhcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBnbHRmRGVmLmV4dHJhcyA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnVzZXJEYXRhID0gZ2x0ZkRlZi5leHRyYXM7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSWdub3JpbmcgcHJpbWl0aXZlIHR5cGUgLmV4dHJhcywgJyArIGdsdGZEZWYuZXh0cmFzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbW9ycGgtdGFyZ2V0c1xuXHQgKlxuXHQgKiBAcGFyYW0ge1RIUkVFLkJ1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHQgKiBAcGFyYW0ge0FycmF5PEdMVEYuVGFyZ2V0Pn0gdGFyZ2V0c1xuXHQgKiBAcGFyYW0ge0dMVEZQYXJzZXJ9IHBhcnNlclxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkJ1ZmZlckdlb21ldHJ5Pn1cblx0ICovXG5cdGZ1bmN0aW9uIGFkZE1vcnBoVGFyZ2V0cyggZ2VvbWV0cnksIHRhcmdldHMsIHBhcnNlciApIHtcblxuXHRcdHZhciBoYXNNb3JwaFBvc2l0aW9uID0gZmFsc2U7XG5cdFx0dmFyIGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdFx0aWYgKCB0YXJnZXQuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIGhhc01vcnBoUG9zaXRpb24gPSB0cnVlO1xuXHRcdFx0aWYgKCB0YXJnZXQuTk9STUFMICE9PSB1bmRlZmluZWQgKSBoYXNNb3JwaE5vcm1hbCA9IHRydWU7XG5cblx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiAmJiBoYXNNb3JwaE5vcm1hbCApIGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIGhhc01vcnBoUG9zaXRpb24gJiYgISBoYXNNb3JwaE5vcm1hbCApIHJldHVybiBQcm9taXNlLnJlc29sdmUoIGdlb21ldHJ5ICk7XG5cblx0XHR2YXIgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzID0gW107XG5cdFx0dmFyIHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5QT1NJVElPTiAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0LlBPU0lUSU9OIClcblx0XHRcdFx0XHQ6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0cGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2goIHBlbmRpbmdBY2Nlc3NvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzTW9ycGhOb3JtYWwgKSB7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5OT1JNQUwgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdD8gcGFyc2VyLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHRhcmdldC5OT1JNQUwgKVxuXHRcdFx0XHRcdDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRcdFx0cGVuZGluZ05vcm1hbEFjY2Vzc29ycy5wdXNoKCBwZW5kaW5nQWNjZXNzb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBbXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ05vcm1hbEFjY2Vzc29ycyApXG5cdFx0XSApLnRoZW4oIGZ1bmN0aW9uICggYWNjZXNzb3JzICkge1xuXG5cdFx0XHR2YXIgbW9ycGhQb3NpdGlvbnMgPSBhY2Nlc3NvcnNbIDAgXTtcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSBhY2Nlc3NvcnNbIDEgXTtcblxuXHRcdFx0Ly8gQ2xvbmUgbW9ycGggdGFyZ2V0IGFjY2Vzc29ycyBiZWZvcmUgbW9kaWZ5aW5nIHRoZW0uXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtb3JwaFBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gPT09IG1vcnBoUG9zaXRpb25zWyBpIF0gKSBjb250aW51ZTtcblxuXHRcdFx0XHRtb3JwaFBvc2l0aW9uc1sgaSBdID0gY2xvbmVCdWZmZXJBdHRyaWJ1dGUoIG1vcnBoUG9zaXRpb25zWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbW9ycGhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwgPT09IG1vcnBoTm9ybWFsc1sgaSBdICkgY29udGludWU7XG5cblx0XHRcdFx0bW9ycGhOb3JtYWxzWyBpIF0gPSBjbG9uZUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhOb3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlTmFtZSA9ICdtb3JwaFRhcmdldCcgKyBpO1xuXG5cdFx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiApIHtcblxuXHRcdFx0XHRcdC8vIFRocmVlLmpzIG1vcnBoIHBvc2l0aW9uIGlzIGFic29sdXRlIHZhbHVlLiBUaGUgZm9ybXVsYSBpc1xuXHRcdFx0XHRcdC8vICAgYmFzZVBvc2l0aW9uXG5cdFx0XHRcdFx0Ly8gICAgICsgd2VpZ2h0MCAqICggbW9ycGhQb3NpdGlvbjAgLSBiYXNlUG9zaXRpb24gKVxuXHRcdFx0XHRcdC8vICAgICArIHdlaWdodDEgKiAoIG1vcnBoUG9zaXRpb24xIC0gYmFzZVBvc2l0aW9uIClcblx0XHRcdFx0XHQvLyAgICAgLi4uXG5cdFx0XHRcdFx0Ly8gd2hpbGUgdGhlIGdsVEYgb25lIGlzIHJlbGF0aXZlXG5cdFx0XHRcdFx0Ly8gICBiYXNlUG9zaXRpb25cblx0XHRcdFx0XHQvLyAgICAgKyB3ZWlnaHQwICogZ2xURm1vcnBoUG9zaXRpb24wXG5cdFx0XHRcdFx0Ly8gICAgICsgd2VpZ2h0MSAqIGdsVEZtb3JwaFBvc2l0aW9uMVxuXHRcdFx0XHRcdC8vICAgICAuLi5cblx0XHRcdFx0XHQvLyB0aGVuIHdlIG5lZWQgdG8gY29udmVydCBmcm9tIHJlbGF0aXZlIHRvIGFic29sdXRlIGhlcmUuXG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldC5QT1NJVElPTiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSBtb3JwaFBvc2l0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG5cblx0XHRcdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLnNldFhZWihcblx0XHRcdFx0XHRcdFx0XHRqLFxuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLmdldFgoIGogKSArIHBvc2l0aW9uLmdldFgoIGogKSxcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbkF0dHJpYnV0ZS5nZXRZKCBqICkgKyBwb3NpdGlvbi5nZXRZKCBqICksXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUuZ2V0WiggaiApICsgcG9zaXRpb24uZ2V0WiggaiApXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYXNNb3JwaE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdC8vIHNlZSB0YXJnZXQuUE9TSVRJT04ncyBjb21tZW50XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldC5OT1JNQUwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIG5vcm1hbEF0dHJpYnV0ZSA9IG1vcnBoTm9ybWFsc1sgaSBdO1xuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuXG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBub3JtYWxBdHRyaWJ1dGUuY291bnQ7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKFxuXHRcdFx0XHRcdFx0XHRcdGosXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLmdldFgoIGogKSArIG5vcm1hbC5nZXRYKCBqICksXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLmdldFkoIGogKSArIG5vcm1hbC5nZXRZKCBqICksXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLmdldFooIGogKSArIG5vcm1hbC5nZXRaKCBqIClcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gKSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcblx0XHRcdGlmICggaGFzTW9ycGhOb3JtYWwgKSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1RIUkVFLk1lc2h9IG1lc2hcblx0ICogQHBhcmFtIHtHTFRGLk1lc2h9IG1lc2hEZWZcblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyggbWVzaCwgbWVzaERlZiApIHtcblxuXHRcdG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cblx0XHRpZiAoIG1lc2hEZWYud2VpZ2h0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWVzaERlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPSBtZXNoRGVmLndlaWdodHNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gLmV4dHJhcyBoYXMgdXNlci1kZWZpbmVkIGRhdGEsIHNvIGNoZWNrIHRoYXQgLmV4dHJhcy50YXJnZXROYW1lcyBpcyBhbiBhcnJheS5cblx0XHRpZiAoIG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkoIG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzICkgKSB7XG5cblx0XHRcdHZhciB0YXJnZXROYW1lcyA9IG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzO1xuXG5cdFx0XHRpZiAoIG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCA9PT0gdGFyZ2V0TmFtZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRhcmdldE5hbWVzWyBpIF0gXSA9IGk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXHRmdW5jdGlvbiBpc09iamVjdEVxdWFsKCBhLCBiICkge1xuXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggYSApLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoIGIgKS5sZW5ndGggKSByZXR1cm4gZmFsc2U7XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIGEgKSB7XG5cblx0XHRcdGlmICggYVsga2V5IF0gIT09IGJbIGtleSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZUtleSggcHJpbWl0aXZlRGVmICkge1xuXG5cdFx0dmFyIGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXTtcblx0XHR2YXIgZ2VvbWV0cnlLZXk7XG5cblx0XHRpZiAoIGRyYWNvRXh0ZW5zaW9uICkge1xuXG5cdFx0XHRnZW9tZXRyeUtleSA9ICdkcmFjbzonICsgZHJhY29FeHRlbnNpb24uYnVmZmVyVmlld1xuXHRcdFx0XHQrICc6JyArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXNcblx0XHRcdFx0KyAnOicgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBkcmFjb0V4dGVuc2lvbi5hdHRyaWJ1dGVzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnZW9tZXRyeUtleSA9IHByaW1pdGl2ZURlZi5pbmRpY2VzICsgJzonICsgY3JlYXRlQXR0cmlidXRlc0tleSggcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXMgKSArICc6JyArIHByaW1pdGl2ZURlZi5tb2RlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5S2V5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBhdHRyaWJ1dGVzICkge1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXNLZXkgPSAnJztcblxuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGF0dHJpYnV0ZXMgKS5zb3J0KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0YXR0cmlidXRlc0tleSArPSBrZXlzWyBpIF0gKyAnOicgKyBhdHRyaWJ1dGVzWyBrZXlzWyBpIF0gXSArICc7JztcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzS2V5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjbG9uZUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0dmFyIGNvdW50ID0gYXR0cmlidXRlLmNvdW50O1xuXHRcdFx0dmFyIGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXHRcdFx0dmFyIGFycmF5ID0gYXR0cmlidXRlLmFycmF5LnNsaWNlKCAwLCBjb3VudCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCBjb3VudDsgKysgaSApIHtcblxuXHRcdFx0XHRhcnJheVsgaiArKyBdID0gYXR0cmlidXRlLmdldFgoIGkgKTtcblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkgYXJyYXlbIGogKysgXSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIGFycmF5WyBqICsrIF0gPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xuXHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSBhcnJheVsgaiArKyBdID0gYXR0cmlidXRlLmdldFcoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZS5jbG9uZSgpO1xuXG5cdH1cblxuXHQvKiBHTFRGIFBBUlNFUiAqL1xuXG5cdGZ1bmN0aW9uIEdMVEZQYXJzZXIoIGpzb24sIGV4dGVuc2lvbnMsIG9wdGlvbnMgKSB7XG5cblx0XHR0aGlzLmpzb24gPSBqc29uIHx8IHt9O1xuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIGxvYWRlciBvYmplY3QgY2FjaGVcblx0XHR0aGlzLmNhY2hlID0gbmV3IEdMVEZSZWdpc3RyeSgpO1xuXG5cdFx0Ly8gQnVmZmVyR2VvbWV0cnkgY2FjaGluZ1xuXHRcdHRoaXMucHJpbWl0aXZlQ2FjaGUgPSB7fTtcblxuXHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXHRcdHRoaXMudGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luICk7XG5cblx0XHR0aGlzLmZpbGVMb2FkZXIgPSBuZXcgVEhSRUUuRmlsZUxvYWRlciggdGhpcy5vcHRpb25zLm1hbmFnZXIgKTtcblx0XHR0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cblx0fVxuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblxuXHRcdC8vIENsZWFyIHRoZSBsb2FkZXIgY2FjaGVcblx0XHR0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuXG5cdFx0Ly8gTWFyayB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlXG5cdFx0dGhpcy5tYXJrRGVmcygpO1xuXG5cdFx0UHJvbWlzZS5hbGwoIFtcblxuXHRcdFx0dGhpcy5nZXREZXBlbmRlbmNpZXMoICdzY2VuZScgKSxcblx0XHRcdHRoaXMuZ2V0RGVwZW5kZW5jaWVzKCAnYW5pbWF0aW9uJyApLFxuXHRcdFx0dGhpcy5nZXREZXBlbmRlbmNpZXMoICdjYW1lcmEnICksXG5cblx0XHRdICkudGhlbiggZnVuY3Rpb24gKCBkZXBlbmRlbmNpZXMgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRcdHNjZW5lOiBkZXBlbmRlbmNpZXNbIDAgXVsganNvbi5zY2VuZSB8fCAwIF0sXG5cdFx0XHRcdHNjZW5lczogZGVwZW5kZW5jaWVzWyAwIF0sXG5cdFx0XHRcdGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sgMSBdLFxuXHRcdFx0XHRjYW1lcmFzOiBkZXBlbmRlbmNpZXNbIDIgXSxcblx0XHRcdFx0YXNzZXQ6IGpzb24uYXNzZXQsXG5cdFx0XHRcdHBhcnNlcjogcGFyc2VyLFxuXHRcdFx0XHR1c2VyRGF0YToge31cblx0XHRcdH07XG5cblx0XHRcdGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uICk7XG5cblx0XHRcdG9uTG9hZCggcmVzdWx0ICk7XG5cblx0XHR9ICkuY2F0Y2goIG9uRXJyb3IgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYXJrcyB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlLlxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubWFya0RlZnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG5cdFx0dmFyIHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuXHRcdHZhciBtZXNoRGVmcyA9IHRoaXMuanNvbi5tZXNoZXMgfHwgW107XG5cblx0XHR2YXIgbWVzaFJlZmVyZW5jZXMgPSB7fTtcblx0XHR2YXIgbWVzaFVzZXMgPSB7fTtcblxuXHRcdC8vIE5vdGhpbmcgaW4gdGhlIG5vZGUgZGVmaW5pdGlvbiBpbmRpY2F0ZXMgd2hldGhlciBpdCBpcyBhIEJvbmUgb3IgYW5cblx0XHQvLyBPYmplY3QzRC4gVXNlIHRoZSBza2lucycgam9pbnQgcmVmZXJlbmNlcyB0byBtYXJrIGJvbmVzLlxuXHRcdGZvciAoIHZhciBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXggKysgKSB7XG5cblx0XHRcdHZhciBqb2ludHMgPSBza2luRGVmc1sgc2tpbkluZGV4IF0uam9pbnRzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG5vZGVEZWZzWyBqb2ludHNbIGkgXSBdLmlzQm9uZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIE1lc2hlcyBjYW4gKGFuZCBzaG91bGQpIGJlIHJldXNlZCBieSBtdWx0aXBsZSBub2RlcyBpbiBhIGdsVEYgYXNzZXQuIFRvXG5cdFx0Ly8gYXZvaWQgaGF2aW5nIG1vcmUgdGhhbiBvbmUgVEhSRUUuTWVzaCB3aXRoIHRoZSBzYW1lIG5hbWUsIGNvdW50XG5cdFx0Ly8gcmVmZXJlbmNlcyBhbmQgcmVuYW1lIGluc3RhbmNlcyBiZWxvdy5cblx0XHQvL1xuXHRcdC8vIEV4YW1wbGU6IENlc2l1bU1pbGtUcnVjayBzYW1wbGUgbW9kZWwgcmV1c2VzIFwiV2hlZWxcIiBtZXNoZXMuXG5cdFx0Zm9yICggdmFyIG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCArKyApIHtcblxuXHRcdFx0dmFyIG5vZGVEZWYgPSBub2RlRGVmc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdGlmICggbm9kZURlZi5tZXNoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBtZXNoUmVmZXJlbmNlc1sgbm9kZURlZi5tZXNoIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG1lc2hSZWZlcmVuY2VzWyBub2RlRGVmLm1lc2ggXSA9IG1lc2hVc2VzWyBub2RlRGVmLm1lc2ggXSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lc2hSZWZlcmVuY2VzWyBub2RlRGVmLm1lc2ggXSArKztcblxuXHRcdFx0XHQvLyBOb3RoaW5nIGluIHRoZSBtZXNoIGRlZmluaXRpb24gaW5kaWNhdGVzIHdoZXRoZXIgaXQgaXNcblx0XHRcdFx0Ly8gYSBTa2lubmVkTWVzaCBvciBNZXNoLiBVc2UgdGhlIG5vZGUncyBtZXNoIHJlZmVyZW5jZVxuXHRcdFx0XHQvLyB0byBtYXJrIFNraW5uZWRNZXNoIGlmIG5vZGUgaGFzIHNraW4uXG5cdFx0XHRcdGlmICggbm9kZURlZi5za2luICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtZXNoRGVmc1sgbm9kZURlZi5tZXNoIF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmpzb24ubWVzaFJlZmVyZW5jZXMgPSBtZXNoUmVmZXJlbmNlcztcblx0XHR0aGlzLmpzb24ubWVzaFVzZXMgPSBtZXNoVXNlcztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgc3BlY2lmaWVkIGRlcGVuZGVuY3kgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuT2JqZWN0M0R8VEhSRUUuTWF0ZXJpYWx8VEhSRUUuVGV4dHVyZXxUSFJFRS5BbmltYXRpb25DbGlwfEFycmF5QnVmZmVyfE9iamVjdD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKCB0eXBlLCBpbmRleCApIHtcblxuXHRcdHZhciBjYWNoZUtleSA9IHR5cGUgKyAnOicgKyBpbmRleDtcblx0XHR2YXIgZGVwZW5kZW5jeSA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY3kgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc2NlbmUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdub2RlJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkTm9kZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtZXNoJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkTWVzaCggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhY2Nlc3Nvcic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFjY2Vzc29yKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2J1ZmZlclZpZXcnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXJWaWV3KCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2J1ZmZlcic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZEJ1ZmZlciggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXRlcmlhbCc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZE1hdGVyaWFsKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RleHR1cmUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRUZXh0dXJlKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3NraW4nOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTa2luKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2FuaW1hdGlvbic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFuaW1hdGlvbiggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdjYW1lcmEnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRDYW1lcmEoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbGlnaHQnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTCBdLmxvYWRMaWdodCggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gdHlwZTogJyArIHR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGRlcGVuZGVuY3kgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5nZXREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cblx0XHR2YXIgZGVwZW5kZW5jaWVzID0gdGhpcy5jYWNoZS5nZXQoIHR5cGUgKTtcblxuXHRcdGlmICggISBkZXBlbmRlbmNpZXMgKSB7XG5cblx0XHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdFx0dmFyIGRlZnMgPSB0aGlzLmpzb25bIHR5cGUgKyAoIHR5cGUgPT09ICdtZXNoJyA/ICdlcycgOiAncycgKSBdIHx8IFtdO1xuXG5cdFx0XHRkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbCggZGVmcy5tYXAoIGZ1bmN0aW9uICggZGVmLCBpbmRleCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koIHR5cGUsIGluZGV4ICk7XG5cblx0XHRcdH0gKSApO1xuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggdHlwZSwgZGVwZW5kZW5jaWVzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRCdWZmZXIgPSBmdW5jdGlvbiAoIGJ1ZmZlckluZGV4ICkge1xuXG5cdFx0dmFyIGJ1ZmZlckRlZiA9IHRoaXMuanNvbi5idWZmZXJzWyBidWZmZXJJbmRleCBdO1xuXHRcdHZhciBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG5cblx0XHRpZiAoIGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSAnYXJyYXlidWZmZXInICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiAnICsgYnVmZmVyRGVmLnR5cGUgKyAnIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgcHJlc2VudCwgR0xCIGNvbnRhaW5lciBpcyByZXF1aXJlZCB0byBiZSB0aGUgZmlyc3QgYnVmZmVyLlxuXHRcdGlmICggYnVmZmVyRGVmLnVyaSA9PT0gdW5kZWZpbmVkICYmIGJ1ZmZlckluZGV4ID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCB0aGlzLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0uYm9keSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXG5cdFx0XHRsb2FkZXIubG9hZCggcmVzb2x2ZVVSTCggYnVmZmVyRGVmLnVyaSwgb3B0aW9ucy5wYXRoICksIHJlc29sdmUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJlamVjdCggbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJyArIGJ1ZmZlckRlZi51cmkgKyAnXCIuJyApICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuXHQgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVmlld0luZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEJ1ZmZlclZpZXcgPSBmdW5jdGlvbiAoIGJ1ZmZlclZpZXdJbmRleCApIHtcblxuXHRcdHZhciBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzWyBidWZmZXJWaWV3SW5kZXggXTtcblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXInLCBidWZmZXJWaWV3RGVmLmJ1ZmZlciApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHR2YXIgYnl0ZUxlbmd0aCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZUxlbmd0aCB8fCAwO1xuXHRcdFx0dmFyIGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3RGVmLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdHJldHVybiBidWZmZXIuc2xpY2UoIGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5CdWZmZXJBdHRyaWJ1dGV8VEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEFjY2Vzc29yID0gZnVuY3Rpb24gKCBhY2Nlc3NvckluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cblx0XHR2YXIgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzWyBhY2Nlc3NvckluZGV4IF07XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHVuZGVmaW5lZCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gSWdub3JlIGVtcHR5IGFjY2Vzc29ycywgd2hpY2ggbWF5IGJlIHVzZWQgdG8gZGVjbGFyZSBydW50aW1lXG5cdFx0XHQvLyBpbmZvcm1hdGlvbiBhYm91dCBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIGFub3RoZXIgc291cmNlIChlLmcuIERyYWNvXG5cdFx0XHQvLyBjb21wcmVzc2lvbiBleHRlbnNpb24pLlxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBlbmRpbmdCdWZmZXJWaWV3cyA9IFtdO1xuXG5cdFx0aWYgKCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3ICkgKTtcblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3ICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZ0J1ZmZlclZpZXdzICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3cyApIHtcblxuXHRcdFx0dmFyIGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1sgMCBdO1xuXG5cdFx0XHR2YXIgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTWyBhY2Nlc3NvckRlZi50eXBlIF07XG5cdFx0XHR2YXIgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSBdO1xuXG5cdFx0XHQvLyBGb3IgVkVDMzogaXRlbVNpemUgaXMgMywgZWxlbWVudEJ5dGVzIGlzIDQsIGl0ZW1CeXRlcyBpcyAxMi5cblx0XHRcdHZhciBlbGVtZW50Qnl0ZXMgPSBUeXBlZEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuXHRcdFx0dmFyIGl0ZW1CeXRlcyA9IGVsZW1lbnRCeXRlcyAqIGl0ZW1TaXplO1xuXHRcdFx0dmFyIGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHR2YXIgYnl0ZVN0cmlkZSA9IGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCA/IGpzb24uYnVmZmVyVmlld3NbIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgXS5ieXRlU3RyaWRlIDogdW5kZWZpbmVkO1xuXHRcdFx0dmFyIG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuXHRcdFx0dmFyIGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdC8vIFRoZSBidWZmZXIgaXMgbm90IGludGVybGVhdmVkIGlmIHRoZSBzdHJpZGUgaXMgdGhlIGl0ZW0gc2l6ZSBpbiBieXRlcy5cblx0XHRcdGlmICggYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMgKSB7XG5cblx0XHRcdFx0dmFyIGliQ2FjaGVLZXkgPSAnSW50ZXJsZWF2ZWRCdWZmZXI6JyArIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKyAnOicgKyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlO1xuXHRcdFx0XHR2YXIgaWIgPSBwYXJzZXIuY2FjaGUuZ2V0KCBpYkNhY2hlS2V5ICk7XG5cblx0XHRcdFx0aWYgKCAhIGliICkge1xuXG5cdFx0XHRcdFx0Ly8gVXNlIHRoZSBmdWxsIGJ1ZmZlciBpZiBpdCdzIGludGVybGVhdmVkLlxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGJ1ZmZlclZpZXcgKTtcblxuXHRcdFx0XHRcdC8vIEludGVnZXIgcGFyYW1ldGVycyB0byBJQi9JQkEgYXJlIGluIGFycmF5IGVsZW1lbnRzLCBub3QgYnl0ZXMuXG5cdFx0XHRcdFx0aWIgPSBuZXcgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIoIGFycmF5LCBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzICk7XG5cblx0XHRcdFx0XHRwYXJzZXIuY2FjaGUuYWRkKCBpYkNhY2hlS2V5LCBpYiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGliLCBpdGVtU2l6ZSwgYnl0ZU9mZnNldCAvIGVsZW1lbnRCeXRlcywgbm9ybWFsaXplZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI3NwYXJzZS1hY2Nlc3NvcnNcblx0XHRcdGlmICggYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuXHRcdFx0XHR2YXIgVHlwZWRBcnJheUluZGljZXMgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmNvbXBvbmVudFR5cGUgXTtcblxuXHRcdFx0XHR2YXIgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRcdHZhciBieXRlT2Zmc2V0VmFsdWVzID0gYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0IHx8IDA7XG5cblx0XHRcdFx0dmFyIHNwYXJzZUluZGljZXMgPSBuZXcgVHlwZWRBcnJheUluZGljZXMoIGJ1ZmZlclZpZXdzWyAxIF0sIGJ5dGVPZmZzZXRJbmRpY2VzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZUluZGljZXMgKTtcblx0XHRcdFx0dmFyIHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3c1sgMiBdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIEF2b2lkIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIsIGlmIHRoZSBidWZmZXJWaWV3IHdhc24ndCBpbml0aWFsaXplZCB3aXRoIHplcm9lcy5cblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUuc2V0QXJyYXkoIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zbGljZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzcGFyc2VJbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gc3BhcnNlSW5kaWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlLnNldFgoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkgYnVmZmVyQXR0cmlidXRlLnNldFkoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSArIDEgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgKyAyIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSBidWZmZXJBdHRyaWJ1dGUuc2V0VyggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplICsgMyBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA1ICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHR2YXIgdGV4dHVyZUxvYWRlciA9IHRoaXMudGV4dHVyZUxvYWRlcjtcblxuXHRcdHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cblx0XHR2YXIgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbIHRleHR1cmVJbmRleCBdO1xuXG5cdFx0dmFyIHRleHR1cmVFeHRlbnNpb25zID0gdGV4dHVyZURlZi5leHRlbnNpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHNvdXJjZTtcblxuXHRcdGlmICggdGV4dHVyZUV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuTVNGVF9URVhUVVJFX0REUyBdICkge1xuXG5cdFx0XHRzb3VyY2UgPSBqc29uLmltYWdlc1sgdGV4dHVyZUV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuTVNGVF9URVhUVVJFX0REUyBdLnNvdXJjZSBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c291cmNlID0ganNvbi5pbWFnZXNbIHRleHR1cmVEZWYuc291cmNlIF07XG5cblx0XHR9XG5cblx0XHR2YXIgc291cmNlVVJJID0gc291cmNlLnVyaTtcblx0XHR2YXIgaXNPYmplY3RVUkwgPSBmYWxzZTtcblxuXHRcdGlmICggc291cmNlLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gTG9hZCBiaW5hcnkgaW1hZ2UgZGF0YSBmcm9tIGJ1ZmZlclZpZXcsIGlmIHByb3ZpZGVkLlxuXG5cdFx0XHRzb3VyY2VVUkkgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBzb3VyY2UuYnVmZmVyVmlldyApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyVmlldyApIHtcblxuXHRcdFx0XHRpc09iamVjdFVSTCA9IHRydWU7XG5cdFx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoIFsgYnVmZmVyVmlldyBdLCB7IHR5cGU6IHNvdXJjZS5taW1lVHlwZSB9ICk7XG5cdFx0XHRcdHNvdXJjZVVSSSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcblx0XHRcdFx0cmV0dXJuIHNvdXJjZVVSSTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggc291cmNlVVJJICkudGhlbiggZnVuY3Rpb24gKCBzb3VyY2VVUkkgKSB7XG5cblx0XHRcdC8vIExvYWQgVGV4dHVyZSByZXNvdXJjZS5cblxuXHRcdFx0dmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIHNvdXJjZVVSSSApO1xuXG5cdFx0XHRpZiAoICEgbG9hZGVyICkge1xuXG5cdFx0XHRcdGxvYWRlciA9IHRleHR1cmVFeHRlbnNpb25zWyBFWFRFTlNJT05TLk1TRlRfVEVYVFVSRV9ERFMgXVxuXHRcdFx0XHRcdD8gcGFyc2VyLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuTVNGVF9URVhUVVJFX0REUyBdLmRkc0xvYWRlclxuXHRcdFx0XHRcdDogdGV4dHVyZUxvYWRlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXG5cdFx0XHRcdGxvYWRlci5sb2FkKCByZXNvbHZlVVJMKCBzb3VyY2VVUkksIG9wdGlvbnMucGF0aCApLCByZXNvbHZlLCB1bmRlZmluZWQsIHJlamVjdCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG5cdFx0XHQvLyBDbGVhbiB1cCByZXNvdXJjZXMgYW5kIGNvbmZpZ3VyZSBUZXh0dXJlLlxuXG5cdFx0XHRpZiAoIGlzT2JqZWN0VVJMID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoIHNvdXJjZVVSSSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlRGVmLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZTtcblxuXHRcdFx0Ly8gSWdub3JlIHVua25vd24gbWltZSB0eXBlcywgbGlrZSBERFMgZmlsZXMuXG5cdFx0XHRpZiAoIHNvdXJjZS5taW1lVHlwZSBpbiBNSU1FX1RZUEVfRk9STUFUUyApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IE1JTUVfVFlQRV9GT1JNQVRTWyBzb3VyY2UubWltZVR5cGUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2FtcGxlcnMgPSBqc29uLnNhbXBsZXJzIHx8IHt9O1xuXHRcdFx0dmFyIHNhbXBsZXIgPSBzYW1wbGVyc1sgdGV4dHVyZURlZi5zYW1wbGVyIF0gfHwge307XG5cblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gV0VCR0xfRklMVEVSU1sgc2FtcGxlci5tYWdGaWx0ZXIgXSB8fCBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbIHNhbXBsZXIubWluRmlsdGVyIF0gfHwgVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS53cmFwUyA9IFdFQkdMX1dSQVBQSU5HU1sgc2FtcGxlci53cmFwUyBdIHx8IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0dGV4dHVyZS53cmFwVCA9IFdFQkdMX1dSQVBQSU5HU1sgc2FtcGxlci53cmFwVCBdIHx8IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSBhc3NpZ25zIGEgdGV4dHVyZSB0byB0aGUgZ2l2ZW4gbWF0ZXJpYWwgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsUGFyYW1zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcblx0ICogQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmFzc2lnblRleHR1cmUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsUGFyYW1zLCBtYXBOYW1lLCBtYXBEZWYgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICd0ZXh0dXJlJywgbWFwRGVmLmluZGV4ICkudGhlbiggZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBtYXBOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2FvTWFwJzpcblx0XHRcdFx0Y2FzZSAnZW1pc3NpdmVNYXAnOlxuXHRcdFx0XHRjYXNlICdtZXRhbG5lc3NNYXAnOlxuXHRcdFx0XHRjYXNlICdub3JtYWxNYXAnOlxuXHRcdFx0XHRjYXNlICdyb3VnaG5lc3NNYXAnOlxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gVEhSRUUuUkdCRm9ybWF0O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFyc2VyLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNIF0gKSB7XG5cblx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB1bmRlZmluZWQgPyBtYXBEZWYuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXSA6IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXS5leHRlbmRUZXh0dXJlKCB0ZXh0dXJlLCB0cmFuc2Zvcm0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXNbIG1hcE5hbWUgXSA9IHRleHR1cmU7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogQXNzaWducyBmaW5hbCBtYXRlcmlhbCB0byBhIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS4gVGhlIGluc3RhbmNlXG5cdCAqIGFscmVhZHkgaGFzIGEgbWF0ZXJpYWwgKGdlbmVyYXRlZCBmcm9tIHRoZSBnbFRGIG1hdGVyaWFsIG9wdGlvbnMgYWxvbmUpXG5cdCAqIGJ1dCByZXVzZSBvZiB0aGUgc2FtZSBnbFRGIG1hdGVyaWFsIG1heSByZXF1aXJlIG11bHRpcGxlIHRocmVlanMgbWF0ZXJpYWxzXG5cdCAqIHRvIGFjY29tb2RhdGUgZGlmZmVyZW50IHByaW1pdGl2ZSB0eXBlcywgZGVmaW5lcywgZXRjLiBOZXcgbWF0ZXJpYWxzIHdpbGxcblx0ICogYmUgY3JlYXRlZCBpZiBuZWNlc3NhcnksIGFuZCByZXVzZWQgZnJvbSBhIGNhY2hlLlxuXHQgKiBAcGFyYW0gIHtUSFJFRS5PYmplY3QzRH0gbWVzaCBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuXG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5hc3NpZ25GaW5hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBtZXNoICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHR2YXIgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuXHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXG5cdFx0dmFyIHVzZVZlcnRleFRhbmdlbnRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ICE9PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHVzZVZlcnRleENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZDtcblx0XHR2YXIgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkO1xuXHRcdHZhciB1c2VTa2lubmluZyA9IG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZTtcblx0XHR2YXIgdXNlTW9ycGhUYXJnZXRzID0gT2JqZWN0LmtleXMoIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyApLmxlbmd0aCA+IDA7XG5cdFx0dmFyIHVzZU1vcnBoTm9ybWFscyA9IHVzZU1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIG1lc2guaXNQb2ludHMgKSB7XG5cblx0XHRcdHZhciBjYWNoZUtleSA9ICdQb2ludHNNYXRlcmlhbDonICsgbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0dmFyIHBvaW50c01hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggISBwb2ludHNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRwb2ludHNNYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCgpO1xuXHRcdFx0XHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBwb2ludHNNYXRlcmlhbCwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5saWdodHMgPSBmYWxzZTsgLy8gUG9pbnRzTWF0ZXJpYWwgZG9lc24ndCBzdXBwb3J0IGxpZ2h0cyB5ZXRcblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIHBvaW50c01hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBwb2ludHNNYXRlcmlhbDtcblxuXHRcdH0gZWxzZSBpZiAoIG1lc2guaXNMaW5lICkge1xuXG5cdFx0XHR2YXIgY2FjaGVLZXkgPSAnTGluZUJhc2ljTWF0ZXJpYWw6JyArIG1hdGVyaWFsLnV1aWQ7XG5cblx0XHRcdHZhciBsaW5lTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCAhIGxpbmVNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRsaW5lTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcblx0XHRcdFx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggbGluZU1hdGVyaWFsLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRsaW5lTWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdFx0bGluZU1hdGVyaWFsLmxpZ2h0cyA9IGZhbHNlOyAvLyBMaW5lQmFzaWNNYXRlcmlhbCBkb2Vzbid0IHN1cHBvcnQgbGlnaHRzIHlldFxuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgbGluZU1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBsaW5lTWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHQvLyBDbG9uZSB0aGUgbWF0ZXJpYWwgaWYgaXQgd2lsbCBiZSBtb2RpZmllZFxuXHRcdGlmICggdXNlVmVydGV4VGFuZ2VudHMgfHwgdXNlVmVydGV4Q29sb3JzIHx8IHVzZUZsYXRTaGFkaW5nIHx8IHVzZVNraW5uaW5nIHx8IHVzZU1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0dmFyIGNhY2hlS2V5ID0gJ0Nsb25lZE1hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkICsgJzonO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzR0xURlNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsICkgY2FjaGVLZXkgKz0gJ3NwZWN1bGFyLWdsb3NzaW5lc3M6Jztcblx0XHRcdGlmICggdXNlU2tpbm5pbmcgKSBjYWNoZUtleSArPSAnc2tpbm5pbmc6Jztcblx0XHRcdGlmICggdXNlVmVydGV4VGFuZ2VudHMgKSBjYWNoZUtleSArPSAndmVydGV4LXRhbmdlbnRzOic7XG5cdFx0XHRpZiAoIHVzZVZlcnRleENvbG9ycyApIGNhY2hlS2V5ICs9ICd2ZXJ0ZXgtY29sb3JzOic7XG5cdFx0XHRpZiAoIHVzZUZsYXRTaGFkaW5nICkgY2FjaGVLZXkgKz0gJ2ZsYXQtc2hhZGluZzonO1xuXHRcdFx0aWYgKCB1c2VNb3JwaFRhcmdldHMgKSBjYWNoZUtleSArPSAnbW9ycGgtdGFyZ2V0czonO1xuXHRcdFx0aWYgKCB1c2VNb3JwaE5vcm1hbHMgKSBjYWNoZUtleSArPSAnbW9ycGgtbm9ybWFsczonO1xuXG5cdFx0XHR2YXIgY2FjaGVkTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCAhIGNhY2hlZE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWwuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWxcblx0XHRcdFx0XHQ/IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdLmNsb25lTWF0ZXJpYWwoIG1hdGVyaWFsIClcblx0XHRcdFx0XHQ6IG1hdGVyaWFsLmNsb25lKCk7XG5cblx0XHRcdFx0aWYgKCB1c2VTa2lubmluZyApIGNhY2hlZE1hdGVyaWFsLnNraW5uaW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VWZXJ0ZXhUYW5nZW50cyApIGNhY2hlZE1hdGVyaWFsLnZlcnRleFRhbmdlbnRzID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VWZXJ0ZXhDb2xvcnMgKSBjYWNoZWRNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XG5cdFx0XHRcdGlmICggdXNlRmxhdFNoYWRpbmcgKSBjYWNoZWRNYXRlcmlhbC5mbGF0U2hhZGluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggdXNlTW9ycGhUYXJnZXRzICkgY2FjaGVkTWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VNb3JwaE5vcm1hbHMgKSBjYWNoZWRNYXRlcmlhbC5tb3JwaE5vcm1hbHMgPSB0cnVlO1xuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgY2FjaGVkTWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IGNhY2hlZE1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gd29ya2Fyb3VuZHMgZm9yIG1lc2ggYW5kIGdlb21ldHJ5XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFvTWFwICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYyID09PSB1bmRlZmluZWQgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLkdMVEZMb2FkZXI6IER1cGxpY2F0aW5nIFVWcyB0byBzdXBwb3J0IGFvTWFwLicgKTtcblx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYuYXJyYXksIDIgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5pc0dMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCApIHtcblxuXHRcdFx0Ly8gZm9yIEdMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbChTaGFkZXJNYXRlcmlhbCkgdW5pZm9ybXMgcnVudGltZSB1cGRhdGVcblx0XHRcdG1lc2gub25CZWZvcmVSZW5kZXIgPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MgXS5yZWZyZXNoVW5pZm9ybXM7XG5cblx0XHR9XG5cblx0XHRtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtYXRlcmlhbHNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1hdGVyaWFsSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5NYXRlcmlhbD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHR2YXIgbWF0ZXJpYWxEZWYgPSBqc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0dmFyIG1hdGVyaWFsVHlwZTtcblx0XHR2YXIgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcblx0XHR2YXIgbWF0ZXJpYWxFeHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRpZiAoIG1hdGVyaWFsRXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTIF0gKSB7XG5cblx0XHRcdHZhciBzZ0V4dGVuc2lvbiA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdO1xuXHRcdFx0bWF0ZXJpYWxUeXBlID0gc2dFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbERlZiApO1xuXHRcdFx0cGVuZGluZy5wdXNoKCBzZ0V4dGVuc2lvbi5leHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUIF0gKSB7XG5cblx0XHRcdHZhciBrbXVFeHRlbnNpb24gPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQgXTtcblx0XHRcdG1hdGVyaWFsVHlwZSA9IGttdUV4dGVuc2lvbi5nZXRNYXRlcmlhbFR5cGUoIG1hdGVyaWFsRGVmICk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFNwZWNpZmljYXRpb246XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbWV0YWxsaWMtcm91Z2huZXNzLW1hdGVyaWFsXG5cblx0XHRcdG1hdGVyaWFsVHlwZSA9IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuXG5cdFx0XHR2YXIgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcyB8fCB7fTtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yICkgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5tZXRhbG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciAhPT0gdW5kZWZpbmVkID8gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgOiAxLjA7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDEuMDtcblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21ldGFsbmVzc01hcCcsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSApICk7XG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAncm91Z2huZXNzTWFwJywgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5kb3VibGVTaWRlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XG5cblx0XHR9XG5cblx0XHR2YXIgYWxwaGFNb2RlID0gbWF0ZXJpYWxEZWYuYWxwaGFNb2RlIHx8IEFMUEhBX01PREVTLk9QQVFVRTtcblxuXHRcdGlmICggYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5CTEVORCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLk1BU0sgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuYWxwaGFUZXN0ID0gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmIDogMC41O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ25vcm1hbE1hcCcsIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgKSApO1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldCggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSwgbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2FvTWFwJywgbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSApICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmFvTWFwSW50ZW5zaXR5ID0gbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2VtaXNzaXZlTWFwJywgbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsVHlwZSA9PT0gVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MgXS5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxQYXJhbXMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBtYXRlcmlhbFR5cGUoIG1hdGVyaWFsUGFyYW1zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gbWF0ZXJpYWxEZWYubmFtZTtcblxuXHRcdFx0Ly8gYmFzZUNvbG9yVGV4dHVyZSwgZW1pc3NpdmVUZXh0dXJlLCBhbmQgc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSB1c2Ugc1JHQiBlbmNvZGluZy5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkgbWF0ZXJpYWwubWFwLmVuY29kaW5nID0gVEhSRUUuc1JHQkVuY29kaW5nO1xuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwLmVuY29kaW5nID0gVEhSRUUuc1JHQkVuY29kaW5nO1xuXHRcdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwLmVuY29kaW5nID0gVEhSRUUuc1JHQkVuY29kaW5nO1xuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VEhSRUUuQnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG5cdCAqIEBwYXJhbSB7R0xURi5QcmltaXRpdmV9IHByaW1pdGl2ZURlZlxuXHQgKiBAcGFyYW0ge0dMVEZQYXJzZXJ9IHBhcnNlclxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkJ1ZmZlckdlb21ldHJ5Pn1cblx0ICovXG5cdGZ1bmN0aW9uIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoIGFjY2Vzc29ySW5kZXgsIGF0dHJpYnV0ZU5hbWUgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgYWNjZXNzb3JJbmRleCApXG5cdFx0XHRcdC50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lLCBhY2Nlc3NvciApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBnbHRmQXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgZ2x0ZkF0dHJpYnV0ZU5hbWUgXSB8fCBnbHRmQXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHQvLyBTa2lwIGF0dHJpYnV0ZXMgYWxyZWFkeSBwcm92aWRlZCBieSBlLmcuIERyYWNvIGV4dGVuc2lvbi5cblx0XHRcdGlmICggdGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSBjb250aW51ZTtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciggYXR0cmlidXRlc1sgZ2x0ZkF0dHJpYnV0ZU5hbWUgXSwgdGhyZWVBdHRyaWJ1dGVOYW1lICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHVuZGVmaW5lZCAmJiAhIGdlb21ldHJ5LmluZGV4ICkge1xuXG5cdFx0XHR2YXIgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgcHJpbWl0aXZlRGVmLmluZGljZXMgKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBhY2Nlc3NvciApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggYWNjZXNzb3IgKTtcblxuXHRcdH1cblxuXHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYgKTtcblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBhZGRNb3JwaFRhcmdldHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyIClcblx0XHRcdFx0OiBnZW9tZXRyeTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcblx0ICpcblx0ICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxUSFJFRS5CdWZmZXJHZW9tZXRyeT4+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEdlb21ldHJpZXMgPSBmdW5jdGlvbiAoIHByaW1pdGl2ZXMgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHR2YXIgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUoIHByaW1pdGl2ZSApIHtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXVxuXHRcdFx0XHQuZGVjb2RlUHJpbWl0aXZlKCBwcmltaXRpdmUsIHBhcnNlciApXG5cdFx0XHRcdC50aGVuKCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlciApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblx0XHRcdHZhciBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleSggcHJpbWl0aXZlICk7XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgdGhpcyBnZW9tZXRyeVxuXHRcdFx0dmFyIGNhY2hlZCA9IGNhY2hlWyBjYWNoZUtleSBdO1xuXG5cdFx0XHRpZiAoIGNhY2hlZCApIHtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIGNhY2hlZCBnZW9tZXRyeSBpZiBpdCBleGlzdHNcblx0XHRcdFx0cGVuZGluZy5wdXNoKCBjYWNoZWQucHJvbWlzZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeVByb21pc2U7XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmUuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiBdICkge1xuXG5cdFx0XHRcdFx0Ly8gVXNlIERSQUNPIGdlb21ldHJ5IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdGdlb21ldHJ5UHJvbWlzZSA9IGNyZWF0ZURyYWNvUHJpbWl0aXZlKCBwcmltaXRpdmUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBnZW9tZXRyeVxuXHRcdFx0XHRcdGdlb21ldHJ5UHJvbWlzZSA9IGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLCBwcmltaXRpdmUsIHBhcnNlciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWNoZSB0aGlzIGdlb21ldHJ5XG5cdFx0XHRcdGNhY2hlWyBjYWNoZUtleSBdID0geyBwcmltaXRpdmU6IHByaW1pdGl2ZSwgcHJvbWlzZTogZ2VvbWV0cnlQcm9taXNlIH07XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBnZW9tZXRyeVByb21pc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtZXNoZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1lc2hJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkdyb3VwfFRIUkVFLk1lc2h8VEhSRUUuU2tpbm5lZE1lc2g+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZE1lc2ggPSBmdW5jdGlvbiAoIG1lc2hJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXG5cdFx0dmFyIG1lc2hEZWYgPSBqc29uLm1lc2hlc1sgbWVzaEluZGV4IF07XG5cdFx0dmFyIHByaW1pdGl2ZXMgPSBtZXNoRGVmLnByaW1pdGl2ZXM7XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKClcblx0XHRcdFx0OiB0aGlzLmdldERlcGVuZGVuY3koICdtYXRlcmlhbCcsIHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoIG9yaWdpbmFsTWF0ZXJpYWxzICkge1xuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLmxvYWRHZW9tZXRyaWVzKCBwcmltaXRpdmVzICkudGhlbiggZnVuY3Rpb24gKCBnZW9tZXRyaWVzICkge1xuXG5cdFx0XHRcdHZhciBtZXNoZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGkgXTtcblx0XHRcdFx0XHR2YXIgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gMS4gY3JlYXRlIE1lc2hcblxuXHRcdFx0XHRcdHZhciBtZXNoO1xuXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb3JpZ2luYWxNYXRlcmlhbHNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgfHxcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgfHxcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOIHx8XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUubW9kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyAuaXNTa2lubmVkTWVzaCBpc24ndCBpbiBnbFRGIHNwZWMuIFNlZSAubWFya0RlZnMoKVxuXHRcdFx0XHRcdFx0bWVzaCA9IG1lc2hEZWYuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHQ/IG5ldyBUSFJFRS5Ta2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsIClcblx0XHRcdFx0XHRcdFx0OiBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHRcdGlmICggbWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlICkgbWVzaC5ub3JtYWxpemVTa2luV2VpZ2h0cygpOyAvLyAjMTUzMTlcblxuXHRcdFx0XHRcdFx0aWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQICkge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2guZHJhd01vZGUgPSBUSFJFRS5UcmlhbmdsZVN0cmlwRHJhd01vZGU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOICkge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2guZHJhd01vZGUgPSBUSFJFRS5UcmlhbmdsZUZhbkRyYXdNb2RlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTICkge1xuXG5cdFx0XHRcdFx0XHRtZXNoID0gbmV3IFRIUkVFLkxpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVAgKSB7XG5cblx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUCApIHtcblxuXHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBUSFJFRS5MaW5lTG9vcCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUyApIHtcblxuXHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBUSFJFRS5Qb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogUHJpbWl0aXZlIG1vZGUgdW5zdXBwb3J0ZWQ6ICcgKyBwcmltaXRpdmUubW9kZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBPYmplY3Qua2V5cyggbWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHR1cGRhdGVNb3JwaFRhcmdldHMoIG1lc2gsIG1lc2hEZWYgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1lc2gubmFtZSA9IG1lc2hEZWYubmFtZSB8fCAoICdtZXNoXycgKyBtZXNoSW5kZXggKTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAxICkgbWVzaC5uYW1lICs9ICdfJyArIGk7XG5cblx0XHRcdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBtZXNoLCBtZXNoRGVmICk7XG5cblx0XHRcdFx0XHRwYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbCggbWVzaCApO1xuXG5cdFx0XHRcdFx0bWVzaGVzLnB1c2goIG1lc2ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtZXNoZXMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG1lc2hlc1sgMCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Z3JvdXAuYWRkKCBtZXNoZXNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZ3JvdXA7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjY2FtZXJhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gY2FtZXJhSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5DYW1lcmE+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZENhbWVyYSA9IGZ1bmN0aW9uICggY2FtZXJhSW5kZXggKSB7XG5cblx0XHR2YXIgY2FtZXJhO1xuXHRcdHZhciBjYW1lcmFEZWYgPSB0aGlzLmpzb24uY2FtZXJhc1sgY2FtZXJhSW5kZXggXTtcblx0XHR2YXIgcGFyYW1zID0gY2FtZXJhRGVmWyBjYW1lcmFEZWYudHlwZSBdO1xuXG5cdFx0aWYgKCAhIHBhcmFtcyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIGNhbWVyYURlZi50eXBlID09PSAncGVyc3BlY3RpdmUnICkge1xuXG5cdFx0XHRjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIFRIUkVFLk1hdGgucmFkVG9EZWcoIHBhcmFtcy55Zm92ICksIHBhcmFtcy5hc3BlY3RSYXRpbyB8fCAxLCBwYXJhbXMuem5lYXIgfHwgMSwgcGFyYW1zLnpmYXIgfHwgMmU2ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjYW1lcmFEZWYudHlwZSA9PT0gJ29ydGhvZ3JhcGhpYycgKSB7XG5cblx0XHRcdGNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIHBhcmFtcy54bWFnIC8gLSAyLCBwYXJhbXMueG1hZyAvIDIsIHBhcmFtcy55bWFnIC8gMiwgcGFyYW1zLnltYWcgLyAtIDIsIHBhcmFtcy56bmVhciwgcGFyYW1zLnpmYXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY2FtZXJhRGVmLm5hbWUgIT09IHVuZGVmaW5lZCApIGNhbWVyYS5uYW1lID0gY2FtZXJhRGVmLm5hbWU7XG5cblx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBjYW1lcmEsIGNhbWVyYURlZiApO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggY2FtZXJhICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NraW5zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBza2luSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZFNraW4gPSBmdW5jdGlvbiAoIHNraW5JbmRleCApIHtcblxuXHRcdHZhciBza2luRGVmID0gdGhpcy5qc29uLnNraW5zWyBza2luSW5kZXggXTtcblxuXHRcdHZhciBza2luRW50cnkgPSB7IGpvaW50czogc2tpbkRlZi5qb2ludHMgfTtcblxuXHRcdGlmICggc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIHNraW5FbnRyeSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzICkudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0c2tpbkVudHJ5LmludmVyc2VCaW5kTWF0cmljZXMgPSBhY2Nlc3NvcjtcblxuXHRcdFx0cmV0dXJuIHNraW5FbnRyeTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0aW9uSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5BbmltYXRpb25DbGlwPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRBbmltYXRpb24gPSBmdW5jdGlvbiAoIGFuaW1hdGlvbkluZGV4ICkge1xuXG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cblx0XHR2YXIgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zWyBhbmltYXRpb25JbmRleCBdO1xuXG5cdFx0dmFyIHBlbmRpbmdOb2RlcyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgPSBbXTtcblx0XHR2YXIgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nU2FtcGxlcnMgPSBbXTtcblx0XHR2YXIgcGVuZGluZ1RhcmdldHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGFubmVsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzWyBpIF07XG5cdFx0XHR2YXIgc2FtcGxlciA9IGFuaW1hdGlvbkRlZi5zYW1wbGVyc1sgY2hhbm5lbC5zYW1wbGVyIF07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gY2hhbm5lbC50YXJnZXQ7XG5cdFx0XHR2YXIgbmFtZSA9IHRhcmdldC5ub2RlICE9PSB1bmRlZmluZWQgPyB0YXJnZXQubm9kZSA6IHRhcmdldC5pZDsgLy8gTk9URTogdGFyZ2V0LmlkIGlzIGRlcHJlY2F0ZWQuXG5cdFx0XHR2YXIgaW5wdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbIHNhbXBsZXIuaW5wdXQgXSA6IHNhbXBsZXIuaW5wdXQ7XG5cdFx0XHR2YXIgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzWyBzYW1wbGVyLm91dHB1dCBdIDogc2FtcGxlci5vdXRwdXQ7XG5cblx0XHRcdHBlbmRpbmdOb2Rlcy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdub2RlJywgbmFtZSApICk7XG5cdFx0XHRwZW5kaW5nSW5wdXRBY2Nlc3NvcnMucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBpbnB1dCApICk7XG5cdFx0XHRwZW5kaW5nT3V0cHV0QWNjZXNzb3JzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgb3V0cHV0ICkgKTtcblx0XHRcdHBlbmRpbmdTYW1wbGVycy5wdXNoKCBzYW1wbGVyICk7XG5cdFx0XHRwZW5kaW5nVGFyZ2V0cy5wdXNoKCB0YXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggW1xuXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ05vZGVzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ0lucHV0QWNjZXNzb3JzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ091dHB1dEFjY2Vzc29ycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdTYW1wbGVycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdUYXJnZXRzIClcblxuXHRcdF0gKS50aGVuKCBmdW5jdGlvbiAoIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0dmFyIG5vZGVzID0gZGVwZW5kZW5jaWVzWyAwIF07XG5cdFx0XHR2YXIgaW5wdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbIDEgXTtcblx0XHRcdHZhciBvdXRwdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbIDIgXTtcblx0XHRcdHZhciBzYW1wbGVycyA9IGRlcGVuZGVuY2llc1sgMyBdO1xuXHRcdFx0dmFyIHRhcmdldHMgPSBkZXBlbmRlbmNpZXNbIDQgXTtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuXHRcdFx0XHR2YXIgaW5wdXRBY2Nlc3NvciA9IGlucHV0QWNjZXNzb3JzWyBpIF07XG5cdFx0XHRcdHZhciBvdXRwdXRBY2Nlc3NvciA9IG91dHB1dEFjY2Vzc29yc1sgaSBdO1xuXHRcdFx0XHR2YXIgc2FtcGxlciA9IHNhbXBsZXJzWyBpIF07XG5cdFx0XHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBub2RlID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRub2RlLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0XHRub2RlLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBUeXBlZEtleWZyYW1lVHJhY2s7XG5cblx0XHRcdFx0c3dpdGNoICggUEFUSF9QUk9QRVJUSUVTWyB0YXJnZXQucGF0aCBdICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0czpcblxuXHRcdFx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjaztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMucm90YXRpb246XG5cblx0XHRcdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy5zY2FsZTpcblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRUeXBlZEtleWZyYW1lVHJhY2sgPSBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuXG5cdFx0XHRcdHZhciBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB1bmRlZmluZWQgPyBJTlRFUlBPTEFUSU9OWyBzYW1wbGVyLmludGVycG9sYXRpb24gXSA6IFRIUkVFLkludGVycG9sYXRlTGluZWFyO1xuXG5cdFx0XHRcdHZhciB0YXJnZXROYW1lcyA9IFtdO1xuXG5cdFx0XHRcdGlmICggUEFUSF9QUk9QRVJUSUVTWyB0YXJnZXQucGF0aCBdID09PSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0cyApIHtcblxuXHRcdFx0XHRcdC8vIE5vZGUgbWF5IGJlIGEgVEhSRUUuR3JvdXAgKGdsVEYgbWVzaCB3aXRoIHNldmVyYWwgcHJpbWl0aXZlcykgb3IgYSBUSFJFRS5NZXNoLlxuXHRcdFx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc01lc2ggPT09IHRydWUgJiYgb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcblxuXHRcdFx0XHRcdFx0XHR0YXJnZXROYW1lcy5wdXNoKCBvYmplY3QubmFtZSA/IG9iamVjdC5uYW1lIDogb2JqZWN0LnV1aWQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0YXJnZXROYW1lcy5wdXNoKCB0YXJnZXROYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG5cdFx0XHRcdFx0XHR0YXJnZXROYW1lc1sgaiBdICsgJy4nICsgUEFUSF9QUk9QRVJUSUVTWyB0YXJnZXQucGF0aCBdLFxuXHRcdFx0XHRcdFx0aW5wdXRBY2Nlc3Nvci5hcnJheSxcblx0XHRcdFx0XHRcdG91dHB1dEFjY2Vzc29yLmFycmF5LFxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBpbnRlcnBvbGF0aW9uIHdpdGggY3VzdG9tIGZhY3RvcnkgbWV0aG9kLlxuXHRcdFx0XHRcdGlmICggc2FtcGxlci5pbnRlcnBvbGF0aW9uID09PSAnQ1VCSUNTUExJTkUnICkge1xuXG5cdFx0XHRcdFx0XHR0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgQ1VCSUNTUExJTkUga2V5ZnJhbWUgaW4gZ2xURiBoYXMgdGhyZWUgb3V0cHV0IHZhbHVlcyBmb3IgZWFjaCBpbnB1dCB2YWx1ZSxcblx0XHRcdFx0XHRcdFx0Ly8gcmVwcmVzZW50aW5nIGluVGFuZ2VudCwgc3BsaW5lVmVydGV4LCBhbmQgb3V0VGFuZ2VudC4gQXMgYSByZXN1bHQsIHRyYWNrLmdldFZhbHVlU2l6ZSgpXG5cdFx0XHRcdFx0XHRcdC8vIG11c3QgYmUgZGl2aWRlZCBieSB0aHJlZSB0byBnZXQgdGhlIGludGVycG9sYW50J3Mgc2FtcGxlU2l6ZSBhcmd1bWVudC5cblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSAvIDMsIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyBNYXJrIGFzIENVQklDU1BMSU5FLiBgdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpYCBkb2Vzbid0IHN1cHBvcnQgY3VzdG9tIGludGVycG9sYW50cy5cblx0XHRcdFx0XHRcdHRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyYWNrcy5wdXNoKCB0cmFjayApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmFtZSA9IGFuaW1hdGlvbkRlZi5uYW1lICE9PSB1bmRlZmluZWQgPyBhbmltYXRpb25EZWYubmFtZSA6ICdhbmltYXRpb25fJyArIGFuaW1hdGlvbkluZGV4O1xuXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIG5hbWUsIHVuZGVmaW5lZCwgdHJhY2tzICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI25vZGVzLWFuZC1oaWVyYXJjaHlcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLk9iamVjdDNEPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWROb2RlID0gZnVuY3Rpb24gKCBub2RlSW5kZXggKSB7XG5cblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblxuXHRcdHZhciBtZXNoUmVmZXJlbmNlcyA9IGpzb24ubWVzaFJlZmVyZW5jZXM7XG5cdFx0dmFyIG1lc2hVc2VzID0ganNvbi5tZXNoVXNlcztcblxuXHRcdHZhciBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRyZXR1cm4gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIC5pc0JvbmUgaXNuJ3QgaW4gZ2xURiBzcGVjLiBTZWUgLm1hcmtEZWZzXG5cdFx0XHRpZiAoIG5vZGVEZWYuaXNCb25lID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIG5ldyBUSFJFRS5Cb25lKCkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbm9kZURlZi5tZXNoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbWVzaCcsIG5vZGVEZWYubWVzaCApLnRoZW4oIGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdFx0XHRcdHZhciBub2RlO1xuXG5cdFx0XHRcdFx0aWYgKCBtZXNoUmVmZXJlbmNlc1sgbm9kZURlZi5tZXNoIF0gPiAxICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2VOdW0gPSBtZXNoVXNlc1sgbm9kZURlZi5tZXNoIF0gKys7XG5cblx0XHRcdFx0XHRcdG5vZGUgPSBtZXNoLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRub2RlLm5hbWUgKz0gJ19pbnN0YW5jZV8nICsgaW5zdGFuY2VOdW07XG5cblx0XHRcdFx0XHRcdC8vIG9uQmVmb3JlUmVuZGVyIGNvcHkgZm9yIFNwZWN1bGFyLUdsb3NzaW5lc3Ncblx0XHRcdFx0XHRcdG5vZGUub25CZWZvcmVSZW5kZXIgPSBtZXNoLm9uQmVmb3JlUmVuZGVyO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRub2RlLmNoaWxkcmVuWyBpIF0ubmFtZSArPSAnX2luc3RhbmNlXycgKyBpbnN0YW5jZU51bTtcblx0XHRcdFx0XHRcdFx0bm9kZS5jaGlsZHJlblsgaSBdLm9uQmVmb3JlUmVuZGVyID0gbWVzaC5jaGlsZHJlblsgaSBdLm9uQmVmb3JlUmVuZGVyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRub2RlID0gbWVzaDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlmIHdlaWdodHMgYXJlIHByb3ZpZGVkIG9uIHRoZSBub2RlLCBvdmVycmlkZSB3ZWlnaHRzIG9uIHRoZSBtZXNoLlxuXHRcdFx0XHRcdGlmICggbm9kZURlZi53ZWlnaHRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggbyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoICEgby5pc01lc2ggKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vZGVEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG8ubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPSBub2RlRGVmLndlaWdodHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbm9kZURlZi5jYW1lcmEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdjYW1lcmEnLCBub2RlRGVmLmNhbWVyYSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBub2RlRGVmLmV4dGVuc2lvbnNcblx0XHRcdFx0JiYgbm9kZURlZi5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9MSUdIVFNfUFVOQ1RVQUwgXVxuXHRcdFx0XHQmJiBub2RlRGVmLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTCBdLmxpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbGlnaHQnLCBub2RlRGVmLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTCBdLmxpZ2h0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggbmV3IFRIUkVFLk9iamVjdDNEKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSgpICkudGhlbiggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYubmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG5vZGUubmFtZSA9IFRIUkVFLlByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCBub2RlRGVmLm5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBub2RlLCBub2RlRGVmICk7XG5cblx0XHRcdGlmICggbm9kZURlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBub2RlLCBub2RlRGVmICk7XG5cblx0XHRcdGlmICggbm9kZURlZi5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggbm9kZURlZi5tYXRyaXggKTtcblx0XHRcdFx0bm9kZS5hcHBseU1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnRyYW5zbGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLnBvc2l0aW9uLmZyb21BcnJheSggbm9kZURlZi50cmFuc2xhdGlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGUucXVhdGVybmlvbi5mcm9tQXJyYXkoIG5vZGVEZWYucm90YXRpb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLnNjYWxlLmZyb21BcnJheSggbm9kZURlZi5zY2FsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2NlbmVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2VuZUluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuU2NlbmU+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZFNjZW5lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gc2NlbmUgbm9kZSBoaWVyYWNoeSBidWlsZGVyXG5cblx0XHRmdW5jdGlvbiBidWlsZE5vZGVIaWVyYWNoeSggbm9kZUlkLCBwYXJlbnRPYmplY3QsIGpzb24sIHBhcnNlciApIHtcblxuXHRcdFx0dmFyIG5vZGVEZWYgPSBqc29uLm5vZGVzWyBub2RlSWQgXTtcblxuXHRcdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbm9kZScsIG5vZGVJZCApLnRoZW4oIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuc2tpbiA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG5vZGU7XG5cblx0XHRcdFx0Ly8gYnVpbGQgc2tlbGV0b24gaGVyZSBhcyB3ZWxsXG5cblx0XHRcdFx0dmFyIHNraW5FbnRyeTtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdza2luJywgbm9kZURlZi5za2luICkudGhlbiggZnVuY3Rpb24gKCBza2luICkge1xuXG5cdFx0XHRcdFx0c2tpbkVudHJ5ID0gc2tpbjtcblxuXHRcdFx0XHRcdHZhciBwZW5kaW5nSm9pbnRzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2tpbkVudHJ5LmpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0cGVuZGluZ0pvaW50cy5wdXNoKCBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ25vZGUnLCBza2luRW50cnkuam9pbnRzWyBpIF0gKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nSm9pbnRzICk7XG5cblx0XHRcdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggam9pbnROb2RlcyApIHtcblxuXHRcdFx0XHRcdHZhciBtZXNoZXMgPSBub2RlLmlzR3JvdXAgPT09IHRydWUgPyBub2RlLmNoaWxkcmVuIDogWyBub2RlIF07XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgbWVzaCA9IG1lc2hlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHR2YXIgYm9uZXMgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGpvaW50Tm9kZSA9IGpvaW50Tm9kZXNbIGogXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGpvaW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGJvbmVzLnB1c2goIGpvaW50Tm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHNraW5FbnRyeS5pbnZlcnNlQmluZE1hdHJpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG1hdC5mcm9tQXJyYXkoIHNraW5FbnRyeS5pbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBqICogMTYgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJvbmVJbnZlcnNlcy5wdXNoKCBtYXQgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRW50cnkuam9pbnRzWyBqIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWVzaC5iaW5kKCBuZXcgVEhSRUUuU2tlbGV0b24oIGJvbmVzLCBib25lSW52ZXJzZXMgKSwgbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdC8vIGJ1aWxkIG5vZGUgaGllcmFjaHlcblxuXHRcdFx0XHRwYXJlbnRPYmplY3QuYWRkKCBub2RlICk7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuY2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBub2RlRGVmLmNoaWxkcmVuO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXHRcdFx0XHRcdFx0cGVuZGluZy5wdXNoKCBidWlsZE5vZGVIaWVyYWNoeSggY2hpbGQsIG5vZGUsIGpzb24sIHBhcnNlciApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9hZFNjZW5lKCBzY2VuZUluZGV4ICkge1xuXG5cdFx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdFx0dmFyIHNjZW5lRGVmID0gdGhpcy5qc29uLnNjZW5lc1sgc2NlbmVJbmRleCBdO1xuXHRcdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cblx0XHRcdHZhciBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXHRcdFx0aWYgKCBzY2VuZURlZi5uYW1lICE9PSB1bmRlZmluZWQgKSBzY2VuZS5uYW1lID0gc2NlbmVEZWYubmFtZTtcblxuXHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggc2NlbmUsIHNjZW5lRGVmICk7XG5cblx0XHRcdGlmICggc2NlbmVEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgc2NlbmUsIHNjZW5lRGVmICk7XG5cblx0XHRcdHZhciBub2RlSWRzID0gc2NlbmVEZWYubm9kZXMgfHwgW107XG5cblx0XHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub2RlSWRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggYnVpbGROb2RlSGllcmFjaHkoIG5vZGVJZHNbIGkgXSwgc2NlbmUsIGpzb24sIHBhcnNlciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBzY2VuZTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0cmV0dXJuIEdMVEZMb2FkZXI7XG5cbn0gKSgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/GLTFLoader.js\n");

/***/ }),

/***/ "./scripts/main.js":
/*!*************************!*\
  !*** ./scripts/main.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_GLTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/GLTFLoader */ \"./js/GLTFLoader.js\");\n/* harmony import */ var _words__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./words */ \"./scripts/words.js\");\n// import * as THREE from '../js/three';\n\n //Scene and Camera-------------------------------------------\n\nvar scene = new THREE.Scene();\nvar camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\ncamera.position.z = 15;\ncamera.position.x = -10;\ncamera.position.y = 5;\nvar renderer = new THREE.WebGLRenderer({\n  antialias: true\n});\nrenderer.setClearColor(\"#e5e5e5\");\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\nwindow.addEventListener('resize', function () {\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n}); //rifle------------------------------------------------------\n\nvar rifle2;\nvar loader = new _js_GLTFLoader__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nloader.load('3Dmodels/rifle2.glb', function (gltf) {\n  rifle2 = gltf.scene;\n  rifle2.scale.x = rifle2.scale.y = rifle2.scale.z = 5; // rifle2.rotation.y = Math.PI * .5;\n\n  rifle2.rotation.y = Math.PI;\n  scene.add(rifle2);\n  console.log(\"sychronous\");\n});\nconsole.log(\"asyncrhrous\");\nvar flash;\nloader.load('3Dmodels/muzzle_flashes.glb', function (gltf) {\n  flash = gltf.scene;\n}); //floor------------------------------------------------------\n\nvar meshFloor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000, 100, 100), new THREE.MeshBasicMaterial({\n  color: 0xffffff,\n  wireframe: true\n}));\nmeshFloor.rotation.x = Math.PI / 2; // Rotate the floor 90 degrees\n\nmeshFloor.position.y -= 10;\nmeshFloor.position.z -= 200;\nscene.add(meshFloor); // camera.position.set(0, player.height, -5);\n// camera.lookAt(new THREE.Vector3(0, 1.8, 0));\n\nvar stage; // const loader = new GLTFLoader();\n\nloader.load('3Dmodels/Hallway.glb', function (gltf) {\n  stage = gltf.scene; // stage.scale.x = stage.scale.y = stage.scale.z = 15;\n  // stage.rotation.y = Math.PI * .5;\n  // stage.rotation.x = \n  // stage.rotation.x = Math.PI * .5;\n\n  stage.position.x = 100;\n  stage.position.z = 20; // stage.position.y = -150;\n\n  scene.add(stage);\n}); //words------------------------------------------------------\n\nvar textloader = new THREE.FontLoader();\nvar meshWord;\n\nvar randomWord = function randomWord() {\n  return _words__WEBPACK_IMPORTED_MODULE_1__[\"default\"][Math.floor(Math.random() * _words__WEBPACK_IMPORTED_MODULE_1__[\"default\"].length)];\n};\n\nvar wordSplitter = function wordSplitter(word) {\n  var words = word.split('');\n  return words;\n};\n\nvar letterList;\n\nvar letterGenerator = function letterGenerator(word) {\n  var letters = wordSplitter(word);\n  letterList = [];\n  letters.forEach(function (el) {\n    textloader.load('node_modules/three/examples/fonts/droid/droid_sans_regular.typeface.json', function (font) {\n      console.log(el);\n      var textGeo = new THREE.TextGeometry(el, {\n        font: font,\n        size: 50,\n        height: 5,\n        curveSegments: 50,\n        bevelEnabled: false,\n        bevelThickness: 1,\n        bevelSize: 8,\n        bevelOffset: 0,\n        bevelSegments: 50\n      });\n      meshWord = new THREE.Mesh(textGeo, new THREE.MeshLambertMaterial({\n        color: 0x00f0ff\n      }));\n      meshWord.rotation.x = Math.PI * .1;\n      scene.add(meshWord);\n      letterList.push(meshWord);\n    });\n  });\n};\n\nvar light3 = new THREE.PointLight(0xFFFFFF, 2, 1000);\nlight3.position.set(camera.position.x, camera.position.y, camera.position.z);\nscene.add(light3); //KeyPress--------------------------------------------------\n// document.addEventListener('keydown', (e) => {\n//     let value = String.fromCharCode(e.keyCode);\n//     console.log(value)\n// })\n\nvar meshWord2;\ntextloader.load('node_modules/three/examples/fonts/droid/droid_sans_regular.typeface.json', function (font) {\n  var textGeo2 = new THREE.TextGeometry(randomWord, {\n    font: font,\n    size: 50,\n    height: 5,\n    curveSegments: 50,\n    bevelEnabled: false,\n    bevelThickness: 1,\n    bevelSize: 8,\n    bevelOffset: 0,\n    bevelSegments: 50\n  });\n  meshWord2 = new THREE.Mesh(textGeo2, new THREE.MeshLambertMaterial({\n    color: 0x00f0ff\n  }));\n  meshWord2.rotation.x = Math.PI * .1;\n  scene.add(meshWord2);\n  var light3 = new THREE.PointLight(0xFFFFFF, 2, 1000);\n  light3.position.set(camera.position.x, camera.position.y, camera.position.z);\n  scene.add(light3);\n}); //lighting=--------------------------------------------------\n\nvar light = new THREE.PointLight(0xFFFFFF, 1, 1000);\nlight.position.set(0, 0, 0);\nscene.add(light);\nvar light2 = new THREE.PointLight(0xFFFFFF, 2, 1000);\nlight.position.set(0, 0, 25);\nscene.add(light2); //Render------------------------------------------------------\n\nvar movingUp = false;\nvar xOffset = -150;\nvar yOffset = 20;\nvar zOffset = -1000;\nvar newWord = false;\nletterGenerator(randomWord());\ndocument.addEventListener('keyup', function (e) {\n  if (String.fromCharCode(e.keyCode) === \" \") {\n    letterList = [];\n    letterGenerator(randomWord());\n    newWord = true;\n    zOffset = -1000;\n  }\n});\nvar currentLetter;\nvar muzzle = false;\ndocument.addEventListener('keydown', function (e) {\n  var value = String.fromCharCode(e.keyCode);\n  currentLetter = value.toLowerCase();\n  console.log(currentLetter);\n\n  if (!(value == \" \")) {\n    muzzle = true;\n    flash.rotation.y = Math.PI;\n    scene.add(flash);\n    flash.children[1].material.color.r = 0.4;\n    flash.children[1].material.color.g = 0;\n    flash.children[1].material.color.b = 0;\n    flash.position.z = rifle2.position.z - 28;\n    flash.position.x = rifle2.position.x;\n    flash.position.y = rifle2.position.y + 3;\n  }\n\n  debugger;\n});\nvar lettersToRemove = [];\n\nvar render = function render() {\n  requestAnimationFrame(render);\n  renderer.render(scene, camera);\n  camera.position.z -= 0.3;\n  rifle2.position.z -= 0.3; // const WordMaker = () => {\n  // debugger\n\n  if (newWord) {\n    for (var i = 0; i < letterList.length; i++) {\n      var wordOffset = i * 50;\n      var el = letterList[i];\n      el.position.x = camera.position.x + xOffset + wordOffset;\n      el.position.y = camera.position.y + yOffset;\n      el.position.z = camera.position.z + zOffset;\n\n      if (el.position.z >= camera.position.z - 100) {\n        newWord = false;\n        scene.remove(el);\n      } // if(currentLetter === null) {\n      // }\n\n\n      if (el.geometry.parameters.text === currentLetter && i == 0) {\n        // debugger\n        scene.remove(el);\n        currentLetter = \"\";\n        letterList.shift();\n      } // const keyPress = document.addEventListener('keydown', (e) => {\n      //     let value = String.fromCharCode(e.keyCode);\n      //     if (el.geometry.parameters.text === value.toLowerCase()){\n      //         scene.remove(el)\n      //     }\n      //     document.removeEventListener('keydown', keyPress)\n      //     // console.log(el)\n      //     // debugger\n      // })\n\n    }\n\n    zOffset += 4;\n  } // }\n  // meshWord2.position.x = camera.position.x + xOffset\n  // meshWord2.position.y = camera.position.y + yOffset\n  // meshWord2.position.z = camera.position.z + zOffset\n  // zOffset += 1\n  // light3.position.x = camera.position.x - 100\n  // light3.position.y = camera.position.y\n  // light3.position.z = camera.position.z - 200\n\n\n  if (movingUp) {\n    rifle2.position.y -= 0.02;\n  } else if (!movingUp) {\n    rifle2.position.y += 0.02;\n  }\n\n  if (rifle2.position.y > 0.3) {\n    movingUp = true;\n  } else if (rifle2.position.y < -0.3) {\n    movingUp = false;\n  }\n\n  var riflezPos;\n\n  if (muzzle) {\n    rifle2.position.y += 0.2;\n    rifle2.rotation.z += 0.1;\n    riflezPos = rifle2.position.z;\n    rifle2.position.z += 0.3;\n    muzzle = false;\n  } else if (rifle2.rotation.z > 0) {\n    rifle2.rotation.z -= 0.15;\n    rifle2.position.z += 0.1;\n  } else if (rifle2.rotation.z < 0) {\n    rifle2.rotation.z = 0;\n    scene.remove(flash);\n    rifle2.position.z = camera.position.z - 12;\n  }\n\n  console.log(rifle2.position.z);\n\n  if (rifle2.position.z < riflezPos) {\n    debugger;\n    rifle2.position.z = riflezPos;\n  }\n};\n\nrender(); // var raycaster = new THREE.Raycaster();\n// var mouse = new THREE.Vector2();\n// var geometry = new THREE.BoxGeometry(1, 1, 1);\n// var material = new THREE.MeshLambertMaterial({ color: 0xF7F7F7 });\n//var mesh = new THREE.Mesh(geometry, material);\n//scene.add(mesh);\n// let meshX = -10;\n// for (var i = 0; i < 15; i++) {\n//     var mesh = new THREE.Mesh(geometry, material);\n//     mesh.position.x = (Math.random() - 0.5) * 10;\n//     mesh.position.y = (Math.random() - 0.5) * 10;\n//     mesh.position.z = (Math.random() - 0.5) * 10;\n//     scene.add(mesh);\n//     meshX += 1;\n// }\n// function onMouseMove(event) {\n//     event.preventDefault();\n//     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n//     mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n//     raycaster.setFromCamera(mouse, camera);\n//     var intersects = raycaster.intersectObjects(scene.children, true);\n//     for (var i = 0; i < intersects.length; i++) {\n//         this.tl = new TimelineMax();\n//         this.tl.to(intersects[i].object.scale, 1, { x: 2, ease: Expo.easeOut })\n//         this.tl.to(intersects[i].object.scale, .5, { x: .5, ease: Expo.easeOut })\n//         this.tl.to(intersects[i].object.position, .5, { x: 2, ease: Expo.easeOut })\n//         this.tl.to(intersects[i].object.rotation, .5, { y: Math.PI * .5, ease: Expo.easeOut }, \"=-1.5\")\n//     }\n// }\n// window.addEventListener('mousemove', onMouseMove);\n// renderer.render(scene, camera)\n// var mtlLoader = new THREE.MTLLoader();\n// mtlLoader.setResourcePath('/3Dmodels/');\n// mtlLoader.setPath('/3Dmodels/');\n// mtlLoader.load('rifle.mtl', function (materials) {\n//     materials.preload();\n//     var objLoader = new THREE.OBJLoader();\n//     objLoader.setMaterials(materials);\n//     objLoader.setPath('/3Dmodels/');\n//     objLoader.load('rifle.obj', function (object) {\n//         console.log(object)\n//         scene.add(object);\n//         // object.position.z -= 1000;\n//     });\n// });\n// const objloader = new THREE.OBJLoader();\n// objloader.load('3Dmodels/rifle.obj', handle_load)\n// console.log(objloader)\n// function handle_load(geometry, materials) {\n//     let mesh = new THREE.Mesh(geometry, materials);\n//     scene.add(mesh)\n//     mesh.position.z = -1000\n// }\n// loader.load('path/to/model.glb', function (gltf) {\n//     scene.add(gltf.scene);\n// })\n// const animate = function() {\n//     requestAnimationFrame(animate);\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHRzL21haW4uanM/Njc4YyJdLCJuYW1lcyI6WyJzY2VuZSIsIlRIUkVFIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInBvc2l0aW9uIiwieiIsIngiLCJ5IiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwic2V0Q2xlYXJDb2xvciIsInNldFNpemUiLCJkb2N1bWVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInJpZmxlMiIsImxvYWRlciIsIkdMVEZMb2FkZXIiLCJsb2FkIiwiZ2x0ZiIsInNjYWxlIiwicm90YXRpb24iLCJNYXRoIiwiUEkiLCJhZGQiLCJjb25zb2xlIiwibG9nIiwiZmxhc2giLCJtZXNoRmxvb3IiLCJNZXNoIiwiUGxhbmVHZW9tZXRyeSIsIk1lc2hCYXNpY01hdGVyaWFsIiwiY29sb3IiLCJ3aXJlZnJhbWUiLCJzdGFnZSIsInRleHRsb2FkZXIiLCJGb250TG9hZGVyIiwibWVzaFdvcmQiLCJyYW5kb21Xb3JkIiwid29yZExpc3QiLCJmbG9vciIsInJhbmRvbSIsImxlbmd0aCIsIndvcmRTcGxpdHRlciIsIndvcmQiLCJ3b3JkcyIsInNwbGl0IiwibGV0dGVyTGlzdCIsImxldHRlckdlbmVyYXRvciIsImxldHRlcnMiLCJmb3JFYWNoIiwiZWwiLCJmb250IiwidGV4dEdlbyIsIlRleHRHZW9tZXRyeSIsInNpemUiLCJoZWlnaHQiLCJjdXJ2ZVNlZ21lbnRzIiwiYmV2ZWxFbmFibGVkIiwiYmV2ZWxUaGlja25lc3MiLCJiZXZlbFNpemUiLCJiZXZlbE9mZnNldCIsImJldmVsU2VnbWVudHMiLCJNZXNoTGFtYmVydE1hdGVyaWFsIiwicHVzaCIsImxpZ2h0MyIsIlBvaW50TGlnaHQiLCJzZXQiLCJtZXNoV29yZDIiLCJ0ZXh0R2VvMiIsImxpZ2h0IiwibGlnaHQyIiwibW92aW5nVXAiLCJ4T2Zmc2V0IiwieU9mZnNldCIsInpPZmZzZXQiLCJuZXdXb3JkIiwiZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImtleUNvZGUiLCJjdXJyZW50TGV0dGVyIiwibXV6emxlIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImNoaWxkcmVuIiwibWF0ZXJpYWwiLCJyIiwiZyIsImIiLCJsZXR0ZXJzVG9SZW1vdmUiLCJyZW5kZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpIiwid29yZE9mZnNldCIsInJlbW92ZSIsImdlb21ldHJ5IiwicGFyYW1ldGVycyIsInRleHQiLCJzaGlmdCIsInJpZmxlelBvcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtDQUlBOztBQUNBLElBQU1BLEtBQUssR0FBRyxJQUFJQyxLQUFLLENBQUNDLEtBQVYsRUFBZDtBQUVBLElBQU1DLE1BQU0sR0FBRyxJQUFJRixLQUFLLENBQUNHLGlCQUFWLENBQTRCLEVBQTVCLEVBQWdDQyxNQUFNLENBQUNDLFVBQVAsR0FBb0JELE1BQU0sQ0FBQ0UsV0FBM0QsRUFBd0UsR0FBeEUsRUFBNkUsSUFBN0UsQ0FBZjtBQUNBSixNQUFNLENBQUNLLFFBQVAsQ0FBZ0JDLENBQWhCLEdBQW9CLEVBQXBCO0FBQ0FOLE1BQU0sQ0FBQ0ssUUFBUCxDQUFnQkUsQ0FBaEIsR0FBb0IsQ0FBQyxFQUFyQjtBQUNBUCxNQUFNLENBQUNLLFFBQVAsQ0FBZ0JHLENBQWhCLEdBQW9CLENBQXBCO0FBRUEsSUFBTUMsUUFBUSxHQUFHLElBQUlYLEtBQUssQ0FBQ1ksYUFBVixDQUF3QjtBQUFFQyxXQUFTLEVBQUU7QUFBYixDQUF4QixDQUFqQjtBQUNBRixRQUFRLENBQUNHLGFBQVQsQ0FBdUIsU0FBdkI7QUFDQUgsUUFBUSxDQUFDSSxPQUFULENBQWlCWCxNQUFNLENBQUNDLFVBQXhCLEVBQW9DRCxNQUFNLENBQUNFLFdB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Q0FBZ0JDLENBQWhCLEdBQW9Cb0csU0FBeEIsRUFBbUM7QUFDL0I7QUFDQXJGLFVBQU0sQ0FBQ2hCLFFBQVAsQ0FBZ0JDLENBQWhCLEdBQW9Cb0csU0FBcEI7QUFDSDtBQUdKLENBckZEOztBQXVGQVQsTUFBTSxHLENBeUJOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0k7QUFFQTtBQUNKO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zY3JpcHRzL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICcuLi9qcy90aHJlZSc7XHJcbmltcG9ydCBHTFRGTG9hZGVyIGZyb20gJy4uL2pzL0dMVEZMb2FkZXInO1xyXG5pbXBvcnQgd29yZExpc3QgZnJvbSAnLi93b3JkcydcclxuXHJcblxyXG4vL1NjZW5lIGFuZCBDYW1lcmEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcblxyXG5jb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApXHJcbmNhbWVyYS5wb3NpdGlvbi56ID0gMTU7XHJcbmNhbWVyYS5wb3NpdGlvbi54ID0gLTEwO1xyXG5jYW1lcmEucG9zaXRpb24ueSA9IDU7XHJcblxyXG5jb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlIH0pO1xyXG5yZW5kZXJlci5zZXRDbGVhckNvbG9yKFwiI2U1ZTVlNVwiKTtcclxucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcclxuXHJcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xyXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgIGNhbWVyYS5hc3BlY3QgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHJcbiAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG59KVxyXG4vL3JpZmxlLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmxldCByaWZsZTI7XHJcbmNvbnN0IGxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCk7XHJcbmxvYWRlci5sb2FkKCczRG1vZGVscy9yaWZsZTIuZ2xiJywgZnVuY3Rpb24gKGdsdGYpIHtcclxuICAgIHJpZmxlMiA9IGdsdGYuc2NlbmU7XHJcbiAgICByaWZsZTIuc2NhbGUueCA9IHJpZmxlMi5zY2FsZS55ID0gcmlmbGUyLnNjYWxlLnogPSA1O1xyXG4gICAgLy8gcmlmbGUyLnJvdGF0aW9uLnkgPSBNYXRoLlBJICogLjU7XHJcbiAgICByaWZsZTIucm90YXRpb24ueSA9IE1hdGguUEk7XHJcbiAgICBzY2VuZS5hZGQocmlmbGUyKTtcclxuICAgIGNvbnNvbGUubG9nKFwic3ljaHJvbm91c1wiKVxyXG59KVxyXG5jb25zb2xlLmxvZyhcImFzeW5jcmhyb3VzXCIpXHJcbmxldCBmbGFzaDtcclxubG9hZGVyLmxvYWQoJzNEbW9kZWxzL211enpsZV9mbGFzaGVzLmdsYicsIGZ1bmN0aW9uIChnbHRmKXtcclxuICAgIGZsYXNoID0gZ2x0Zi5zY2VuZTtcclxufSlcclxuLy9mbG9vci0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbmxldCBtZXNoRmxvb3IgPSBuZXcgVEhSRUUuTWVzaChcclxuICAgICAgICBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgxMDAwLCAxMDAwLCAxMDAsIDEwMCksXHJcbiAgICAgICAgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmLCB3aXJlZnJhbWU6IHRydWUgfSlcclxuICAgICk7XHJcbiAgICBtZXNoRmxvb3Iucm90YXRpb24ueCA9IE1hdGguUEkgLyAyOyAvLyBSb3RhdGUgdGhlIGZsb29yIDkwIGRlZ3JlZXNcclxuICAgIG1lc2hGbG9vci5wb3NpdGlvbi55IC09IDEwXHJcbiAgICBtZXNoRmxvb3IucG9zaXRpb24ueiAtPSAyMDBcclxuICAgIHNjZW5lLmFkZChtZXNoRmxvb3IpO1xyXG5cclxuICAgIC8vIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgcGxheWVyLmhlaWdodCwgLTUpO1xyXG4gICAgLy8gY2FtZXJhLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLCAxLjgsIDApKTtcclxubGV0IHN0YWdlO1xyXG4vLyBjb25zdCBsb2FkZXIgPSBuZXcgR0xURkxvYWRlcigpO1xyXG5sb2FkZXIubG9hZCgnM0Rtb2RlbHMvSGFsbHdheS5nbGInLCBmdW5jdGlvbiAoZ2x0Zikge1xyXG4gICAgc3RhZ2UgPSBnbHRmLnNjZW5lO1xyXG4gICAgLy8gc3RhZ2Uuc2NhbGUueCA9IHN0YWdlLnNjYWxlLnkgPSBzdGFnZS5zY2FsZS56ID0gMTU7XHJcbiAgICAvLyBzdGFnZS5yb3RhdGlvbi55ID0gTWF0aC5QSSAqIC41O1xyXG4gICAgLy8gc3RhZ2Uucm90YXRpb24ueCA9IFxyXG4gICAgLy8gc3RhZ2Uucm90YXRpb24ueCA9IE1hdGguUEkgKiAuNTtcclxuICAgIHN0YWdlLnBvc2l0aW9uLnggPSAxMDA7XHJcbiAgICBzdGFnZS5wb3NpdGlvbi56ID0gMjA7IFxyXG4gICAgLy8gc3RhZ2UucG9zaXRpb24ueSA9IC0xNTA7XHJcblxyXG5cclxuICAgIHNjZW5lLmFkZChzdGFnZSk7XHJcbn0pXHJcblxyXG5cclxuLy93b3Jkcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxubGV0IHRleHRsb2FkZXIgPSBuZXcgVEhSRUUuRm9udExvYWRlcigpO1xyXG5sZXQgbWVzaFdvcmQ7XHJcbmNvbnN0IHJhbmRvbVdvcmQgPSAoKSA9PiB3b3JkTGlzdFtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB3b3JkTGlzdC5sZW5ndGgpXVxyXG5cclxuXHJcblxyXG5jb25zdCB3b3JkU3BsaXR0ZXIgPSAod29yZCkgPT4ge1xyXG4gICAgbGV0IHdvcmRzID0gd29yZC5zcGxpdCgnJylcclxuICAgIHJldHVybiB3b3Jkc1xyXG59XHJcblxyXG5sZXQgbGV0dGVyTGlzdDsgXHJcblxyXG5cclxuY29uc3QgbGV0dGVyR2VuZXJhdG9yID0gZnVuY3Rpb24od29yZCkge1xyXG4gICAgbGV0IGxldHRlcnMgPSB3b3JkU3BsaXR0ZXIod29yZClcclxuICAgIGxldHRlckxpc3QgPSBbXTtcclxuICAgIGxldHRlcnMuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgdGV4dGxvYWRlci5sb2FkKCdub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvZm9udHMvZHJvaWQvZHJvaWRfc2Fuc19yZWd1bGFyLnR5cGVmYWNlLmpzb24nLCBmdW5jdGlvbiAoZm9udCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlbClcclxuICAgICAgICAgICAgbGV0IHRleHRHZW8gPSBuZXcgVEhSRUUuVGV4dEdlb21ldHJ5KGVsLCB7XHJcbiAgICAgICAgICAgICAgICBmb250OiBmb250LFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogNTAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUsXHJcbiAgICAgICAgICAgICAgICBjdXJ2ZVNlZ21lbnRzOiA1MCxcclxuICAgICAgICAgICAgICAgIGJldmVsRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiZXZlbFRoaWNrbmVzczogMSxcclxuICAgICAgICAgICAgICAgIGJldmVsU2l6ZTogOCxcclxuICAgICAgICAgICAgICAgIGJldmVsT2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgYmV2ZWxTZWdtZW50czogNTBcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgbWVzaFdvcmQgPSBuZXcgVEhSRUUuTWVzaChcclxuICAgICAgICAgICAgICAgIHRleHRHZW8sXHJcbiAgICAgICAgICAgICAgICBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7IGNvbG9yOiAweDAwZjBmZiB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIG1lc2hXb3JkLnJvdGF0aW9uLnggPSBNYXRoLlBJICogLjE7XHJcblxyXG5cclxuICAgICAgICAgICAgc2NlbmUuYWRkKG1lc2hXb3JkKVxyXG4gICAgICAgICAgICBsZXR0ZXJMaXN0LnB1c2gobWVzaFdvcmQpXHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfSlcclxufVxyXG5cclxudmFyIGxpZ2h0MyA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KDB4RkZGRkZGLCAyLCAxMDAwKVxyXG5saWdodDMucG9zaXRpb24uc2V0KGNhbWVyYS5wb3NpdGlvbi54LCBjYW1lcmEucG9zaXRpb24ueSwgY2FtZXJhLnBvc2l0aW9uLnopO1xyXG5zY2VuZS5hZGQobGlnaHQzKTtcclxuXHJcblxyXG4vL0tleVByZXNzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XHJcbi8vICAgICBsZXQgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSk7XHJcbi8vICAgICBjb25zb2xlLmxvZyh2YWx1ZSlcclxuLy8gfSlcclxuXHJcblxyXG5cclxuXHJcbmxldCBtZXNoV29yZDI7XHJcbnRleHRsb2FkZXIubG9hZCgnbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2ZvbnRzL2Ryb2lkL2Ryb2lkX3NhbnNfcmVndWxhci50eXBlZmFjZS5qc29uJywgZnVuY3Rpb24gKGZvbnQpIHtcclxuXHJcbiAgICBsZXQgdGV4dEdlbzIgPSBuZXcgVEhSRUUuVGV4dEdlb21ldHJ5KHJhbmRvbVdvcmQsIHtcclxuICAgICAgICBmb250OiBmb250LFxyXG4gICAgICAgIHNpemU6IDUwLFxyXG4gICAgICAgIGhlaWdodDogNSxcclxuICAgICAgICBjdXJ2ZVNlZ21lbnRzOiA1MCxcclxuICAgICAgICBiZXZlbEVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgIGJldmVsVGhpY2tuZXNzOiAxLFxyXG4gICAgICAgIGJldmVsU2l6ZTogOCxcclxuICAgICAgICBiZXZlbE9mZnNldDogMCxcclxuICAgICAgICBiZXZlbFNlZ21lbnRzOiA1MFxyXG4gICAgfSk7XHJcbiAgICBcclxuXHJcbiAgICBtZXNoV29yZDIgPSBuZXcgVEhSRUUuTWVzaChcclxuICAgICAgICB0ZXh0R2VvMixcclxuICAgICAgICBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7IGNvbG9yOiAweDAwZjBmZiB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIFxyXG4gICAgbWVzaFdvcmQyLnJvdGF0aW9uLnggPSBNYXRoLlBJICogLjE7XHJcbiAgICBcclxuXHJcbiAgICBzY2VuZS5hZGQobWVzaFdvcmQyKVxyXG4gICAgdmFyIGxpZ2h0MyA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KDB4RkZGRkZGLCAyLCAxMDAwKVxyXG4gICAgbGlnaHQzLnBvc2l0aW9uLnNldChjYW1lcmEucG9zaXRpb24ueCwgY2FtZXJhLnBvc2l0aW9uLnksIGNhbWVyYS5wb3NpdGlvbi56KTtcclxuICAgIHNjZW5lLmFkZChsaWdodDMpOyAgIFxyXG59KTtcclxuXHJcblxyXG5cclxuLy9saWdodGluZz0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG52YXIgbGlnaHQgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCgweEZGRkZGRiwgMSwgMTAwMClcclxubGlnaHQucG9zaXRpb24uc2V0KDAsIDAsIDApO1xyXG5zY2VuZS5hZGQobGlnaHQpO1xyXG5cclxudmFyIGxpZ2h0MiA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KDB4RkZGRkZGLCAyLCAxMDAwKVxyXG5saWdodC5wb3NpdGlvbi5zZXQoMCwgMCwgMjUpO1xyXG5zY2VuZS5hZGQobGlnaHQyKTtcclxuXHJcblxyXG4vL1JlbmRlci0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbmxldCBtb3ZpbmdVcCA9IGZhbHNlXHJcbmxldCB4T2Zmc2V0ID0gLTE1MFxyXG5sZXQgeU9mZnNldCA9IDIwXHJcbmxldCB6T2Zmc2V0ID0gLTEwMDBcclxubGV0IG5ld1dvcmQgPSBmYWxzZSBcclxuXHJcbmxldHRlckdlbmVyYXRvcihyYW5kb21Xb3JkKCkpXHJcblxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChlKSA9PiB7XHJcbiAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpID09PSBcIiBcIil7XHJcbiAgICAgICAgbGV0dGVyTGlzdCA9IFtdO1xyXG4gICAgICAgIGxldHRlckdlbmVyYXRvcihyYW5kb21Xb3JkKCkpXHJcbiAgICAgICAgbmV3V29yZCA9IHRydWVcclxuICAgICAgICB6T2Zmc2V0ID0gLTEwMDAgIFxyXG4gICAgICAgIFxyXG4gICAgfVxyXG59KVxyXG5sZXQgY3VycmVudExldHRlcjtcclxubGV0IG11enpsZSA9IGZhbHNlXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xyXG4gICAgbGV0IHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpO1xyXG5cclxuICAgIGN1cnJlbnRMZXR0ZXIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpXHJcbiAgICBjb25zb2xlLmxvZyhjdXJyZW50TGV0dGVyKVxyXG4gICAgaWYoISh2YWx1ZSA9PSBcIiBcIikpIHtcclxuICAgICAgICBtdXp6bGUgPSB0cnVlXHJcbiAgICAgICAgZmxhc2gucm90YXRpb24ueSA9IE1hdGguUEk7XHJcbiAgICAgICAgc2NlbmUuYWRkKGZsYXNoKVxyXG4gICAgICAgIGZsYXNoLmNoaWxkcmVuWzFdLm1hdGVyaWFsLmNvbG9yLnIgPSAwLjRcclxuICAgICAgICBmbGFzaC5jaGlsZHJlblsxXS5tYXRlcmlhbC5jb2xvci5nID0gMFxyXG4gICAgICAgIGZsYXNoLmNoaWxkcmVuWzFdLm1hdGVyaWFsLmNvbG9yLmIgPSAwXHJcbiAgICAgICAgZmxhc2gucG9zaXRpb24ueiA9IHJpZmxlMi5wb3NpdGlvbi56IC0gMjg7XHJcbiAgICAgICAgZmxhc2gucG9zaXRpb24ueCA9IHJpZmxlMi5wb3NpdGlvbi54O1xyXG4gICAgICAgIGZsYXNoLnBvc2l0aW9uLnkgPSByaWZsZTIucG9zaXRpb24ueSArIDM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGRlYnVnZ2VyXHJcblxyXG59KVxyXG5cclxubGV0IGxldHRlcnNUb1JlbW92ZSA9IFtdO1xyXG5cclxuY29uc3QgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7ICAgXHJcbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XHJcbiAgICBjYW1lcmEucG9zaXRpb24ueiAtPSAwLjM7XHJcbiAgICByaWZsZTIucG9zaXRpb24ueiAtPSAwLjM7XHJcbiAgICBcclxuICAgIFxyXG4gICAgLy8gY29uc3QgV29yZE1ha2VyID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIGRlYnVnZ2VyXHJcbiAgICAgICAgaWYobmV3V29yZCl7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV0dGVyTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHdvcmRPZmZzZXQgPSBpICogNTBcclxuICAgICAgICAgICAgbGV0IGVsID0gbGV0dGVyTGlzdFtpXTtcclxuICAgICAgICAgICAgZWwucG9zaXRpb24ueCA9IGNhbWVyYS5wb3NpdGlvbi54ICsgeE9mZnNldCArIHdvcmRPZmZzZXRcclxuICAgICAgICAgICAgZWwucG9zaXRpb24ueSA9IGNhbWVyYS5wb3NpdGlvbi55ICsgeU9mZnNldFxyXG4gICAgICAgICAgICBlbC5wb3NpdGlvbi56ID0gY2FtZXJhLnBvc2l0aW9uLnogKyB6T2Zmc2V0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihlbC5wb3NpdGlvbi56ID49IGNhbWVyYS5wb3NpdGlvbi56IC0gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdXb3JkID0gZmFsc2VcclxuICAgICAgICAgICAgICAgIHNjZW5lLnJlbW92ZShlbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZihjdXJyZW50TGV0dGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbC5nZW9tZXRyeS5wYXJhbWV0ZXJzLnRleHQgPT09IGN1cnJlbnRMZXR0ZXIgJiYgaSA9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWJ1Z2dlclxyXG4gICAgICAgICAgICAgICAgICAgIHNjZW5lLnJlbW92ZShlbClcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGV0dGVyID0gXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIGxldHRlckxpc3Quc2hpZnQoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29uc3Qga2V5UHJlc3MgPSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcclxuICAgICAgICAgICAgLy8gICAgIGxldCB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS5rZXlDb2RlKTtcclxuICAgICAgICAgICAgLy8gICAgIGlmIChlbC5nZW9tZXRyeS5wYXJhbWV0ZXJzLnRleHQgPT09IHZhbHVlLnRvTG93ZXJDYXNlKCkpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBzY2VuZS5yZW1vdmUoZWwpXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleVByZXNzKVxyXG4gICAgICAgICAgICAvLyAgICAgLy8gY29uc29sZS5sb2coZWwpXHJcbiAgICAgICAgICAgIC8vICAgICAvLyBkZWJ1Z2dlclxyXG4gICAgICAgICAgICAvLyB9KVxyXG4gICAgICAgIH0gICBcclxuICAgICAgICB6T2Zmc2V0ICs9IDRcclxuICAgIH1cclxuICAgICAgICBcclxuICAgIC8vIH1cclxuICAgIC8vIG1lc2hXb3JkMi5wb3NpdGlvbi54ID0gY2FtZXJhLnBvc2l0aW9uLnggKyB4T2Zmc2V0XHJcbiAgICAvLyBtZXNoV29yZDIucG9zaXRpb24ueSA9IGNhbWVyYS5wb3NpdGlvbi55ICsgeU9mZnNldFxyXG4gICAgLy8gbWVzaFdvcmQyLnBvc2l0aW9uLnogPSBjYW1lcmEucG9zaXRpb24ueiArIHpPZmZzZXRcclxuICAgIC8vIHpPZmZzZXQgKz0gMVxyXG4gICAgLy8gbGlnaHQzLnBvc2l0aW9uLnggPSBjYW1lcmEucG9zaXRpb24ueCAtIDEwMFxyXG4gICAgLy8gbGlnaHQzLnBvc2l0aW9uLnkgPSBjYW1lcmEucG9zaXRpb24ueVxyXG4gICAgLy8gbGlnaHQzLnBvc2l0aW9uLnogPSBjYW1lcmEucG9zaXRpb24ueiAtIDIwMFxyXG4gICAgXHJcbiAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxuICAgIGlmIChtb3ZpbmdVcCkge3JpZmxlMi5wb3NpdGlvbi55IC09IDAuMDJ9XHJcbiAgICBlbHNlIGlmICghbW92aW5nVXApIHtyaWZsZTIucG9zaXRpb24ueSArPSAwLjAyfVxyXG4gICAgXHJcbiAgICBpZiAocmlmbGUyLnBvc2l0aW9uLnkgPiAwLjMpIHttb3ZpbmdVcCA9IHRydWU7fVxyXG4gICAgZWxzZSBpZiAocmlmbGUyLnBvc2l0aW9uLnkgPCAtMC4zKSB7bW92aW5nVXAgPSBmYWxzZTt9XHJcbiAgICBsZXQgcmlmbGV6UG9zXHJcbiAgICBpZihtdXp6bGUpe1xyXG4gICAgICAgIHJpZmxlMi5wb3NpdGlvbi55ICs9IDAuMlxyXG4gICAgICAgIHJpZmxlMi5yb3RhdGlvbi56ICs9IDAuMVxyXG4gICAgICAgIHJpZmxlelBvcyA9IHJpZmxlMi5wb3NpdGlvbi56XHJcbiAgICAgICAgcmlmbGUyLnBvc2l0aW9uLnogKz0gMC4zXHJcbiAgICAgICAgbXV6emxlID0gZmFsc2VcclxuICAgIH1lbHNlXHJcbiAgICBcclxuICAgIGlmIChyaWZsZTIucm90YXRpb24ueiA+IDApIHtcclxuICAgICAgICByaWZsZTIucm90YXRpb24ueiAtPSAwLjE1XHJcbiAgICAgICAgcmlmbGUyLnBvc2l0aW9uLnogKz0gMC4xXHJcbiAgICB9ZWxzZSBpZiAocmlmbGUyLnJvdGF0aW9uLnogPCAwKXtcclxuICAgICAgICByaWZsZTIucm90YXRpb24ueiA9IDBcclxuICAgICAgICBzY2VuZS5yZW1vdmUoZmxhc2gpXHJcbiAgICAgICAgcmlmbGUyLnBvc2l0aW9uLnogPSBjYW1lcmEucG9zaXRpb24ueiAtIDEyXHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhyaWZsZTIucG9zaXRpb24ueiApXHJcbiAgICBpZiAocmlmbGUyLnBvc2l0aW9uLnogPCByaWZsZXpQb3MpIHtcclxuICAgICAgICBkZWJ1Z2dlclxyXG4gICAgICAgIHJpZmxlMi5wb3NpdGlvbi56ID0gcmlmbGV6UG9zXHJcbiAgICB9XHJcblxyXG5cclxufSBcclxuXHJcbnJlbmRlcigpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyB2YXIgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xyXG4vLyB2YXIgbW91c2UgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG4vLyB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMSwgMSwgMSk7XHJcbi8vIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHsgY29sb3I6IDB4RjdGN0Y3IH0pO1xyXG4vL3ZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuXHJcbi8vc2NlbmUuYWRkKG1lc2gpO1xyXG5cclxuLy8gbGV0IG1lc2hYID0gLTEwO1xyXG4vLyBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyspIHtcclxuICAgIC8vICAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbi8vICAgICBtZXNoLnBvc2l0aW9uLnggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMDtcclxuLy8gICAgIG1lc2gucG9zaXRpb24ueSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwO1xyXG4vLyAgICAgbWVzaC5wb3NpdGlvbi56ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMTA7XHJcbi8vICAgICBzY2VuZS5hZGQobWVzaCk7XHJcbi8vICAgICBtZXNoWCArPSAxO1xyXG4vLyB9XHJcblxyXG5cclxuXHJcbi8vIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAvLyAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIFxyXG4gICAgLy8gICAgIG1vdXNlLnggPSAoZXZlbnQuY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxO1xyXG4vLyAgICAgbW91c2UueSA9IC0gKGV2ZW50LmNsaWVudFkgLyB3aW5kb3cuaW5uZXJIZWlnaHQpICogMiArIDE7XHJcblxyXG4vLyAgICAgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEobW91c2UsIGNhbWVyYSk7XHJcblxyXG4vLyAgICAgdmFyIGludGVyc2VjdHMgPSByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyhzY2VuZS5jaGlsZHJlbiwgdHJ1ZSk7XHJcbi8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVyc2VjdHMubGVuZ3RoOyBpKyspIHtcclxuLy8gICAgICAgICB0aGlzLnRsID0gbmV3IFRpbWVsaW5lTWF4KCk7XHJcbi8vICAgICAgICAgdGhpcy50bC50byhpbnRlcnNlY3RzW2ldLm9iamVjdC5zY2FsZSwgMSwgeyB4OiAyLCBlYXNlOiBFeHBvLmVhc2VPdXQgfSlcclxuLy8gICAgICAgICB0aGlzLnRsLnRvKGludGVyc2VjdHNbaV0ub2JqZWN0LnNjYWxlLCAuNSwgeyB4OiAuNSwgZWFzZTogRXhwby5lYXNlT3V0IH0pXHJcbi8vICAgICAgICAgdGhpcy50bC50byhpbnRlcnNlY3RzW2ldLm9iamVjdC5wb3NpdGlvbiwgLjUsIHsgeDogMiwgZWFzZTogRXhwby5lYXNlT3V0IH0pXHJcbi8vICAgICAgICAgdGhpcy50bC50byhpbnRlcnNlY3RzW2ldLm9iamVjdC5yb3RhdGlvbiwgLjUsIHsgeTogTWF0aC5QSSAqIC41LCBlYXNlOiBFeHBvLmVhc2VPdXQgfSwgXCI9LTEuNVwiKVxyXG4vLyAgICAgfVxyXG4vLyB9XHJcblxyXG5cclxuXHJcbi8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XHJcblxyXG4vLyByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSlcclxuLy8gdmFyIG10bExvYWRlciA9IG5ldyBUSFJFRS5NVExMb2FkZXIoKTtcclxuLy8gbXRsTG9hZGVyLnNldFJlc291cmNlUGF0aCgnLzNEbW9kZWxzLycpO1xyXG4vLyBtdGxMb2FkZXIuc2V0UGF0aCgnLzNEbW9kZWxzLycpO1xyXG4vLyBtdGxMb2FkZXIubG9hZCgncmlmbGUubXRsJywgZnVuY3Rpb24gKG1hdGVyaWFscykge1xyXG5cclxuLy8gICAgIG1hdGVyaWFscy5wcmVsb2FkKCk7XHJcblxyXG4vLyAgICAgdmFyIG9iakxvYWRlciA9IG5ldyBUSFJFRS5PQkpMb2FkZXIoKTtcclxuLy8gICAgIG9iakxvYWRlci5zZXRNYXRlcmlhbHMobWF0ZXJpYWxzKTtcclxuLy8gICAgIG9iakxvYWRlci5zZXRQYXRoKCcvM0Rtb2RlbHMvJyk7XHJcbi8vICAgICBvYmpMb2FkZXIubG9hZCgncmlmbGUub2JqJywgZnVuY3Rpb24gKG9iamVjdCkge1xyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKG9iamVjdClcclxuLy8gICAgICAgICBzY2VuZS5hZGQob2JqZWN0KTtcclxuLy8gICAgICAgICAvLyBvYmplY3QucG9zaXRpb24ueiAtPSAxMDAwO1xyXG5cclxuLy8gICAgIH0pO1xyXG5cclxuLy8gfSk7XHJcblxyXG5cclxuXHJcbi8vIGNvbnN0IG9iamxvYWRlciA9IG5ldyBUSFJFRS5PQkpMb2FkZXIoKTtcclxuLy8gb2JqbG9hZGVyLmxvYWQoJzNEbW9kZWxzL3JpZmxlLm9iaicsIGhhbmRsZV9sb2FkKVxyXG5cclxuLy8gY29uc29sZS5sb2cob2JqbG9hZGVyKVxyXG5cclxuLy8gZnVuY3Rpb24gaGFuZGxlX2xvYWQoZ2VvbWV0cnksIG1hdGVyaWFscykge1xyXG4vLyAgICAgbGV0IG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWxzKTtcclxuLy8gICAgIHNjZW5lLmFkZChtZXNoKVxyXG4vLyAgICAgbWVzaC5wb3NpdGlvbi56ID0gLTEwMDBcclxuLy8gfVxyXG5cclxuLy8gbG9hZGVyLmxvYWQoJ3BhdGgvdG8vbW9kZWwuZ2xiJywgZnVuY3Rpb24gKGdsdGYpIHtcclxuXHJcbi8vICAgICBzY2VuZS5hZGQoZ2x0Zi5zY2VuZSk7XHJcblxyXG4vLyB9KVxyXG5cclxuLy8gY29uc3QgYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4vLyAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4vLyB9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./scripts/main.js\n");

/***/ }),

/***/ "./scripts/words.js":
/*!**************************!*\
  !*** ./scripts/words.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ([\"abet\", \"accord\", \"adept\", \"advocate\", \"agile\", \"allot\", \"aloof\", \"amiss\", \"analogy\", \"anarchy\", \"antics\", \"apprehend\", \"ardent\", \"articulate\", \"assail\", \"assimilate\", \"atrocity\", \"attribute\", \"audacious\", \"augment\", \"authority\", \"avail\", \"avid\", \"awry\", \"balmy\", \"banter\", \"barter\", \"benign\", \"bizarre\", \"bonanza\", \"bountiful\", \"cache\", \"capacious\", \"caption\", \"chastise\", \"citadel\", \"cite\", \"clad\", \"clarify\", \"commemorate\", \"component\", \"concept\", \"confiscate\", \"connoisseur\", \"conscientious\", \"conservative\", \"contagious\", \"conventional\", \"convey\", \"crucial\", \"crusade\", \"culminate\", \"eccentric\", \"elite\", \"embargo\", \"embark\", \"encroach\", \"endeavor\", \"enhance\", \"enigma\", \"epoch\", \"era\", \"eventful\", \"evolve\", \"exceptional\", \"excerpt\", \"excruciating\", \"exemplify\", \"exotic\", \"facilitate\", \"fallacy\", \"fastidious\", \"feasible\", \"fend\", \"ferret\", \"flair\", \"flustered\", \"foreboding\", \"forfeit\", \"formidable\", \"fortify\", \"foster\", \"gaunt\", \"gingerly\", \"glut\", \"grapple\", \"grope\", \"gullible\", \"Haggard\", \"haven\", \"heritage\", \"hindrance\", \"hover\", \"humane\", \"imperative\", \"inaugurate\", \"incense\", \"indifferent\", \"infinite\", \"instill\", \"institute\", \"intervene\", \"intricate\", \"inventive\", \"inventory\", \"irascible\", \"jurisdiction\", \"languish\", \"legendary\", \"liberal\", \"loll\", \"lucrative\", \"luminous\", \"memoir\", \"mercenary\", \"mien\", \"millennium\", \"minimize\", \"modify\", \"muse\", \"muster\", \"onslaught\", \"ornate\", \"ovation\", \"overt\", \"pang\", \"panorama\", \"perspective\", \"phenomenon\", \"pioneer\", \"pithy\", \"pivotal\", \"plausible\", \"plunder\", \"porous\", \"preposterous\", \"principal\", \"prodigy\", \"proficient\", \"profound\", \"pseudonym\", \"pungent\", \"rankle\", \"rational\", \"rebuke\", \"reception\", \"recourse\", \"recur\", \"renounce\", \"renown\", \"revenue\", \"rubble\", \"rue\", \"sage\", \"sedative\", \"serene\", \"servile\", \"shackle\", \"sleek\", \"spontaneous\", \"sporadic\", \"stamina\", \"stance\", \"staple\", \"stint\", \"strident\", \"sublime\", \"subside\", \"succumb\", \"surpass\", \"susceptible\", \"swelter\", \"tedious\", \"teem\", \"theme\", \"tirade\", \"tract\", \"transition\", \"trepidation\", \"turbulent\", \"tycoon\", \"ultimate\", \"ungainly\", \"viceversa\", \"vie\", \"vilify\", \"voracious\", \"Wage\", \"wrangle\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHRzL3dvcmRzLmpzPzA1ODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUE7QUFBZSxnRUFDZixNQURlLEVBRWIsUUFGYSxFQUdiLE9BSGEsRUFJYixVQUphLEVBS2IsT0FMYSxFQU1iLE9BTmEsRUFPYixPQVBhLEVBUWIsT0FSYSxFQVNiLFNBVGEsRUFVYixTQVZhLEVBV2IsUUFYYSxFQVliLFdBWmEsRUFhYixRQWJhLEVBY2QsWUFkYyxFQWVkLFFBZmMsRUFnQmQsWUFoQmMsRUFpQmQsVUFqQmMsRUFrQmQsV0FsQmMsRUFtQmQsV0FuQmMsRUFvQmQsU0FwQmMsRUFxQmQsV0FyQmMsRUFzQmQsT0F0QmMsRUF1QmQsTUF2QmMsRUF3QmQsTUF4QmMsRUF5QmQsT0F6QmMsRUEwQmQsUUExQmMsRUEyQmQsUUEzQmMsRUE0QmQsUUE1QmMsRUE2QmQsU0E3QmMsRUE4QmQsU0E5QmMsRUErQmQsV0EvQmMsRUFnQ2QsT0FoQ2MsRUFpQ2QsV0FqQ2MsRUFrQ2QsU0FsQ2MsRUFtQ2QsVUFuQ2MsRUFvQ2QsU0FwQ2MsRUFxQ2QsTUFyQ2MsRUFzQ2QsTUF0Q2MsRUF1Q2QsU0F2Q2MsRUF3Q2QsYUF4Q2MsRUF5Q2QsV0F6Q2MsRUEwQ2QsU0ExQ2MsRUEyQ2QsWUEzQ2MsRUE0Q2QsYUE1Q2MsRUE2Q2QsZUE3Q2MsRUE4Q2QsY0E5Q2MsRUErQ2QsWUEvQ2MsRUFnRGQsY0FoRGMsRUFpRGQsUUFqRGMsRUFrRGQsU0FsRGMsRUFtRGQsU0FuRGMsRUFvRGQsV0FwRGMsRUFxRGQsV0FyRGMsRUFzRGQsT0F0RGMsRUF1RGQsU0F2RGMsRUF3RGQsUUF4RGMsRUF5RGQsVUF6RGMsRUEwRGQsVUExRGMsRUEyRGQsU0EzRGMsRUE0RGQsUUE1RGMsRUE2RGQsT0E3RGMsRUE4RGQsS0E5RGMsRUErRGQsVUEvRGMsRUFnRWQsUUFoRWMsRUFpRWQsYUFqRWMsRUFrRWQsU0FsRWMsRUFtRWQsY0FuRWMsRUFvRWQsV0FwRWMsRUFxRWQsUUFyRWMsRUFzRWQsWUF0RWMsRUF1RWQsU0F2RWMsRUF3RWQsWUF4RWMsRUF5RWQsVUF6RWMsRUEwRWQsTUExRWMsRUEyRWQsUUEzRWMsRUE0RWQsT0E1RWMsRUE2RWQsV0E3RWMsRUE4RWQsWUE5RWMsRUErRWQsU0EvRWMsRUFnRmQsWUFoRmMsRUFpRmQsU0FqRmMsRUFrRmQsUUFsRmMsRUFtRmQsT0FuRmMsRUFvRmQsVUFwRmMsRUFxRmQsTUFyRmMsRUFzRmQsU0F0RmMsRUF1RmQsT0F2RmMsRUF3RmQsVUF4RmMsRUF5RmQsU0F6RmMsRUEwRmQsT0ExRmMsRUEyRmQsVUEzRmMsRUE0RmQsV0E1RmMsRUE2RmQsT0E3RmMsRUE4RmQsUUE5RmMsRUErRmQsWUEvRmMsRUFnR2QsWUFoR2MsRUFpR2QsU0FqR2MsRUFrR2QsYUFsR2MsRUFtR2QsVUFuR2MsRUFvR2QsU0FwR2MsRUFxR2QsV0FyR2MsRUFzR2QsV0F0R2MsRUF1R2QsV0F2R2MsRUF3R2QsV0F4R2MsRUF5R2QsV0F6R2MsRUEwR2QsV0ExR2MsRUEyR2QsY0EzR2MsRUE0R2QsVUE1R2MsRUE2R2QsV0E3R2MsRUE4R2QsU0E5R2MsRUErR2QsTUEvR2MsRUFnSGQsV0FoSGMsRUFpSGQsVUFqSGMsRUFrSGQsUUFsSGMsRUFtSGQsV0FuSGMsRUFvSGQsTUFwSGMsRUFxSGQsWUFySGMsRUFzSGQsVUF0SGMsRUF1SGQsUUF2SGMsRUF3SGQsTUF4SGMsRUF5SGQsUUF6SGMsRUEwSGQsV0ExSGMsRUEySGQsUUEzSGMsRUE0SGQsU0E1SGMsRUE2SGQsT0E3SGMsRUE4SGQsTUE5SGMsRUErSGQsVUEvSGMsRUFnSWQsYUFoSWMsRUFpSWQsWUFqSWMsRUFrSWQsU0FsSWMsRUFtSWQsT0FuSWMsRUFvSWQsU0FwSWMsRUFxSWQsV0FySWMsRUFzSWQsU0F0SWMsRUF1SWQsUUF2SWMsRUF3SWQsY0F4SWMsRUF5SWQsV0F6SWMsRUEwSWQsU0ExSWMsRUEySWQsWUEzSWMsRUE0SWQsVUE1SWMsRUE2SWQsV0E3SWMsRUE4SWQsU0E5SWMsRUErSWQsUUEvSWMsRUFnSmQsVUFoSmMsRUFpSmQsUUFqSmMsRUFrSmQsV0FsSmMsRUFtSmQsVUFuSmMsRUFvSmQsT0FwSmMsRUFxSmQsVUFySmMsRUFzSmQsUUF0SmMsRUF1SmQsU0F2SmMsRUF3SmQsUUF4SmMsRUF5SmQsS0F6SmMsRUEwSmQsTUExSmMsRUEySmQsVUEzSmMsRUE0SmQsUUE1SmMsRUE2SmQsU0E3SmMsRUE4SmQsU0E5SmMsRUErSmQsT0EvSmMsRUFnS2QsYUFoS2MsRUFpS2QsVUFqS2MsRUFrS2QsU0FsS2MsRUFtS2QsUUFuS2MsRUFvS2QsUUFwS2MsRUFxS2QsT0FyS2MsRUFzS2QsVUF0S2MsRUF1S2QsU0F2S2MsRUF3S2QsU0F4S2MsRUF5S2QsU0F6S2MsRUEwS2QsU0ExS2MsRUEyS2QsYUEzS2MsRUE0S2QsU0E1S2MsRUE2S2QsU0E3S2MsRUE4S2QsTUE5S2MsRUErS2QsT0EvS2MsRUFnTGQsUUFoTGMsRUFpTGQsT0FqTGMsRUFrTGQsWUFsTGMsRUFtTGQsYUFuTGMsRUFvTGQsV0FwTGMsRUFxTGQsUUFyTGMsRUFzTGQsVUF0TGMsRUF1TGQsVUF2TGMsRUF3TGQsV0F4TGMsRUF5TGQsS0F6TGMsRUEwTGQsUUExTGMsRUEyTGQsV0EzTGMsRUE0TGQsTUE1TGMsRUE2TGQsU0E3TGMsQ0FBZiIsImZpbGUiOiIuL3NjcmlwdHMvd29yZHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFtcclxuXCJhYmV0XCJcclxuLCBcImFjY29yZFwiXHJcbiwgXCJhZGVwdFwiXHJcbiwgXCJhZHZvY2F0ZVwiXHJcbiwgXCJhZ2lsZVwiXHJcbiwgXCJhbGxvdFwiXHJcbiwgXCJhbG9vZlwiXHJcbiwgXCJhbWlzc1wiXHJcbiwgXCJhbmFsb2d5XCJcclxuLCBcImFuYXJjaHlcIlxyXG4sIFwiYW50aWNzXCJcclxuLCBcImFwcHJlaGVuZFwiXHJcbiwgXCJhcmRlbnRcIlxyXG4sXCJhcnRpY3VsYXRlXCJcclxuLFwiYXNzYWlsXCJcclxuLFwiYXNzaW1pbGF0ZVwiXHJcbixcImF0cm9jaXR5XCJcclxuLFwiYXR0cmlidXRlXCJcclxuLFwiYXVkYWNpb3VzXCJcclxuLFwiYXVnbWVudFwiXHJcbixcImF1dGhvcml0eVwiXHJcbixcImF2YWlsXCJcclxuLFwiYXZpZFwiXHJcbixcImF3cnlcIlxyXG4sXCJiYWxteVwiXHJcbixcImJhbnRlclwiXHJcbixcImJhcnRlclwiXHJcbixcImJlbmlnblwiXHJcbixcImJpemFycmVcIlxyXG4sXCJib25hbnphXCJcclxuLFwiYm91bnRpZnVsXCJcclxuLFwiY2FjaGVcIlxyXG4sXCJjYXBhY2lvdXNcIlxyXG4sXCJjYXB0aW9uXCJcclxuLFwiY2hhc3Rpc2VcIlxyXG4sXCJjaXRhZGVsXCJcclxuLFwiY2l0ZVwiXHJcbixcImNsYWRcIlxyXG4sXCJjbGFyaWZ5XCJcclxuLFwiY29tbWVtb3JhdGVcIlxyXG4sXCJjb21wb25lbnRcIlxyXG4sXCJjb25jZXB0XCJcclxuLFwiY29uZmlzY2F0ZVwiXHJcbixcImNvbm5vaXNzZXVyXCJcclxuLFwiY29uc2NpZW50aW91c1wiXHJcbixcImNvbnNlcnZhdGl2ZVwiXHJcbixcImNvbnRhZ2lvdXNcIlxyXG4sXCJjb252ZW50aW9uYWxcIlxyXG4sXCJjb252ZXlcIlxyXG4sXCJjcnVjaWFsXCJcclxuLFwiY3J1c2FkZVwiXHJcbixcImN1bG1pbmF0ZVwiXHJcbixcImVjY2VudHJpY1wiXHJcbixcImVsaXRlXCJcclxuLFwiZW1iYXJnb1wiXHJcbixcImVtYmFya1wiXHJcbixcImVuY3JvYWNoXCJcclxuLFwiZW5kZWF2b3JcIlxyXG4sXCJlbmhhbmNlXCJcclxuLFwiZW5pZ21hXCJcclxuLFwiZXBvY2hcIlxyXG4sXCJlcmFcIlxyXG4sXCJldmVudGZ1bFwiXHJcbixcImV2b2x2ZVwiXHJcbixcImV4Y2VwdGlvbmFsXCJcclxuLFwiZXhjZXJwdFwiXHJcbixcImV4Y3J1Y2lhdGluZ1wiXHJcbixcImV4ZW1wbGlmeVwiXHJcbixcImV4b3RpY1wiXHJcbixcImZhY2lsaXRhdGVcIlxyXG4sXCJmYWxsYWN5XCJcclxuLFwiZmFzdGlkaW91c1wiXHJcbixcImZlYXNpYmxlXCJcclxuLFwiZmVuZFwiXHJcbixcImZlcnJldFwiXHJcbixcImZsYWlyXCJcclxuLFwiZmx1c3RlcmVkXCJcclxuLFwiZm9yZWJvZGluZ1wiXHJcbixcImZvcmZlaXRcIlxyXG4sXCJmb3JtaWRhYmxlXCJcclxuLFwiZm9ydGlmeVwiXHJcbixcImZvc3RlclwiXHJcbixcImdhdW50XCJcclxuLFwiZ2luZ2VybHlcIlxyXG4sXCJnbHV0XCJcclxuLFwiZ3JhcHBsZVwiXHJcbixcImdyb3BlXCJcclxuLFwiZ3VsbGlibGVcIlxyXG4sXCJIYWdnYXJkXCJcclxuLFwiaGF2ZW5cIlxyXG4sXCJoZXJpdGFnZVwiXHJcbixcImhpbmRyYW5jZVwiXHJcbixcImhvdmVyXCJcclxuLFwiaHVtYW5lXCJcclxuLFwiaW1wZXJhdGl2ZVwiXHJcbixcImluYXVndXJhdGVcIlxyXG4sXCJpbmNlbnNlXCJcclxuLFwiaW5kaWZmZXJlbnRcIlxyXG4sXCJpbmZpbml0ZVwiXHJcbixcImluc3RpbGxcIlxyXG4sXCJpbnN0aXR1dGVcIlxyXG4sXCJpbnRlcnZlbmVcIlxyXG4sXCJpbnRyaWNhdGVcIlxyXG4sXCJpbnZlbnRpdmVcIlxyXG4sXCJpbnZlbnRvcnlcIlxyXG4sXCJpcmFzY2libGVcIlxyXG4sXCJqdXJpc2RpY3Rpb25cIlxyXG4sXCJsYW5ndWlzaFwiXHJcbixcImxlZ2VuZGFyeVwiXHJcbixcImxpYmVyYWxcIlxyXG4sXCJsb2xsXCJcclxuLFwibHVjcmF0aXZlXCJcclxuLFwibHVtaW5vdXNcIlxyXG4sXCJtZW1vaXJcIlxyXG4sXCJtZXJjZW5hcnlcIlxyXG4sXCJtaWVuXCJcclxuLFwibWlsbGVubml1bVwiXHJcbixcIm1pbmltaXplXCJcclxuLFwibW9kaWZ5XCJcclxuLFwibXVzZVwiXHJcbixcIm11c3RlclwiXHJcbixcIm9uc2xhdWdodFwiXHJcbixcIm9ybmF0ZVwiXHJcbixcIm92YXRpb25cIlxyXG4sXCJvdmVydFwiXHJcbixcInBhbmdcIlxyXG4sXCJwYW5vcmFtYVwiXHJcbixcInBlcnNwZWN0aXZlXCJcclxuLFwicGhlbm9tZW5vblwiXHJcbixcInBpb25lZXJcIlxyXG4sXCJwaXRoeVwiXHJcbixcInBpdm90YWxcIlxyXG4sXCJwbGF1c2libGVcIlxyXG4sXCJwbHVuZGVyXCJcclxuLFwicG9yb3VzXCJcclxuLFwicHJlcG9zdGVyb3VzXCJcclxuLFwicHJpbmNpcGFsXCJcclxuLFwicHJvZGlneVwiXHJcbixcInByb2ZpY2llbnRcIlxyXG4sXCJwcm9mb3VuZFwiXHJcbixcInBzZXVkb255bVwiXHJcbixcInB1bmdlbnRcIlxyXG4sXCJyYW5rbGVcIlxyXG4sXCJyYXRpb25hbFwiXHJcbixcInJlYnVrZVwiXHJcbixcInJlY2VwdGlvblwiXHJcbixcInJlY291cnNlXCJcclxuLFwicmVjdXJcIlxyXG4sXCJyZW5vdW5jZVwiXHJcbixcInJlbm93blwiXHJcbixcInJldmVudWVcIlxyXG4sXCJydWJibGVcIlxyXG4sXCJydWVcIlxyXG4sXCJzYWdlXCJcclxuLFwic2VkYXRpdmVcIlxyXG4sXCJzZXJlbmVcIlxyXG4sXCJzZXJ2aWxlXCJcclxuLFwic2hhY2tsZVwiXHJcbixcInNsZWVrXCJcclxuLFwic3BvbnRhbmVvdXNcIlxyXG4sXCJzcG9yYWRpY1wiXHJcbixcInN0YW1pbmFcIlxyXG4sXCJzdGFuY2VcIlxyXG4sXCJzdGFwbGVcIlxyXG4sXCJzdGludFwiXHJcbixcInN0cmlkZW50XCJcclxuLFwic3VibGltZVwiXHJcbixcInN1YnNpZGVcIlxyXG4sXCJzdWNjdW1iXCJcclxuLFwic3VycGFzc1wiXHJcbixcInN1c2NlcHRpYmxlXCJcclxuLFwic3dlbHRlclwiXHJcbixcInRlZGlvdXNcIlxyXG4sXCJ0ZWVtXCJcclxuLFwidGhlbWVcIlxyXG4sXCJ0aXJhZGVcIlxyXG4sXCJ0cmFjdFwiXHJcbixcInRyYW5zaXRpb25cIlxyXG4sXCJ0cmVwaWRhdGlvblwiXHJcbixcInR1cmJ1bGVudFwiXHJcbixcInR5Y29vblwiXHJcbixcInVsdGltYXRlXCJcclxuLFwidW5nYWlubHlcIlxyXG4sXCJ2aWNldmVyc2FcIlxyXG4sXCJ2aWVcIlxyXG4sXCJ2aWxpZnlcIlxyXG4sXCJ2b3JhY2lvdXNcIlxyXG4sXCJXYWdlXCJcclxuLFwid3JhbmdsZVwiXHJcbl0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scripts/words.js\n");

/***/ })

/******/ });